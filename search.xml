<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LPSD功率谱估计]]></title>
    <url>%2F2019%2F09%2F18%2FLPSD%2F</url>
    <content type="text"><![CDATA[欧洲航空局（ESA）为LISA计划设计了完整的数据处理工具包LTPDA （LISA Technology Package Data Analysis），该工具包中内置一种对数频率点功率谱估计算法，即本文所提的LPSD算法。该算法由文献Improved spectrum estimation from digitized time series on a logarithmic frequency axis 给出。本文作为对该文献学习的总结，同时作为对MATLAB的学习，自编了基于LPSD算法的功率谱估计函数。 常用功率谱估计算法功率谱估计是频域分析的一种常用手段，可用来检测信号中的单频信号或评估仪器的噪声本底等。常用的功率谱估计算法有周期图法（对应MATLAB函数为periofogram）和Welch方法（pwelch）。对于采集系统收集到的数字信号，周期图法会对该数据进行去漂（detrend）和加窗，然后利用快速傅里叶变换（FFT，是DFT的快速算法）将信号转化到频域$$X(k) = \sum\limits_{n = 0}^{N - 1} {x(n){e^{ - i\frac{ {2\pi} } {N}nk}}}$$ 最后利用Parseval等式获得功率谱$$S(k) = \frac{2}{Nf_s}|X(k)|^2$$ 式中，系数2是将双边谱转换到单边谱，这是因为负频率不具备实际的物理意义。Welch方法相对于周期图法增加了分段平均的思想，其将数据等分为多段，并且允许各段数据之间具有一定的重叠率以补偿窗函数引入的数据不平权的影响。对每段数据采用周期图法，最后将各段分别计算的功率谱进算数平均，获得最终的谱估计值。图中展示了周期图法和Welch方法对功率谱估计的结果。其中，蓝色曲线的周期图法一次性使用了全部的数据，因而有最高的频率分辨率，可以看到更低的频带。但是其高频部分的数据波动较大，且波动范围不会随着点数的增加而减小，即不满足所谓的一致性原则。橙色的Welch算法由于对数据进行了分段，直接进行FFT的数据相对较少，导致频率分辨率降低。但是分段平均使得高频波动的幅值大大减小，可以证明波动会随着分段次数的增加而进一步减小。 LPSD算法LPSD算法的基本思想是采用对数分布的频率点，由于此时频率点的差值不是定值，即DFT的频率分辨率随频率点变化，因而在求取每个频率点对应的功率谱密度时应当对原始数据进行不同的分段。这就是说，LPSD算法的每个频率点对应于不同分段次数下Welch算法中的相应点。 对数频率的选取记采集到的离散数据为$x(n),n=0,1,2…N-1$，采样率为$f_s$。假设希望计算$J_{des}$个点，其中第$j$个点对应的频率为$f(j)$、功率谱密度为$P(j)$、频率分辨率为$r(j)=f(j+1)-f(j)$。应当注意的是，这里的频率分辨率是指计算DFT的频率点之间的间隔，更一般的说法应当是栅栏效应。有限长数据的频率分辨率实际由DTFT定义，与数据的时间长度互为导数，本文中称之为最小分辨率。在LPSD算法中不能采用logspace生成对数分布的频率点，因为数值计算的频率间隔不应当小于最小分辨率$r_{min}$，否则这种计算是没有意义的。为了计算频率点，首先考察严格对数均匀的频率点应当满足$$\log f(j + 1) - \log f(j) = C$$其中C为常数。频率范围受分辨率和采样率的影响，取$$f(1)=r_{min}=\frac{f_s}{N},f(J_{des})=f_{max}=\frac{f_s}{2}$$再令$$g=\log f_{max}- \log r_{min}=\log \frac{N}{2}$$ 可以得到第$j$个点的频率和频率分辨率分别为$$f(j)=r_{min} \times 10^{\frac{j-1}{J_{des}-1}g} \\ r_0(j)=f(j)(10^{\frac{g}{J_{des}-1}}-1)$$ 为了使低频段到高频段的频率分辨率变化较连续，对中频段对应的频率分辨率进行调整，为此，引入分段次数期望值$K_{des}$（其典型值为100），在分段重叠率为$\xi$时满足$$({K_{des}} - 1)(1 - \xi ){L_{avg}} + {L_{avg}} = N$$ 此时对应的频率分辨率为$$r_{avg}=\frac{f_s}{L_{avg}}=\frac{f_s}{N}[ (K_{des}-1)(1-\xi) +1 ]$$ 根据分辨率限制和算法需求，我们需要对频率分辨率进行调整，如下$$r’(j) = {\begin{array}{|cc}r_0(j) &amp; ,r_0(j)\ge r_{avg} \\\sqrt{r_0(j) \cdot r_{avg}} &amp; ,r_0(j) &lt; r_{avg}{\rm{ and }}\sqrt{r_0(j) \cdot r_{avg}} &gt; r_{\min } \\r_{min} &amp; ,else \\\end{array}}$$ 除此之外，为了保证依据频率分辨率分段的数据长度为整数，频率分辨率还应当做进一步调整$$L(j) = \left\lfloor{\frac{f_s}{r’(j)}} \right\rfloor \\ r(j) = \frac{f_s}{L(j)}$$ 其中，符号$\left\lfloor \right\rfloor$表示向下取整。综上所述，对数频率的选取算法为：以$f(1)=r_{min}$为起点，根据频率和$J_{des}$求解分辨率$r_0(j)$，并根据要求对分辨率进行调整，得到$r(j)$，接着利用$f(j+1)=f(j)+r(j)$进行迭代。当计算的频率达到奈奎斯特频率即可停止迭代。值得注意的是，由于对频率分辨率进行了修正，获得的频率点并不是严格的对数分布，同时也会导致实际获得的频率点$J$与期望的点数$J_{des}$并不相等。 数据的分段处理对于第$j$个频率点，由前可知其频率分辨率为$r(j)$，分段后的每段数据长度为$L(j)$。为了减小窗函数导致的数据不等权，允许分段之间存在一定的重叠率$\xi$，数据分段如下图所示。由图可知，每段数据未重叠部分长度为$$D(j) = (1 - \xi ) \cdot L(j)$$ 因而分段次数为$$K(j) = \left\lfloor {\frac{N - L(j)} {D(j) + 1} } \right\rfloor $$ 针对每段数据，我们可以选择利用mean函数求取数据平均值后予以扣除，或利用detrend函数直接去除数据中线性漂移。以扣除平均值为例，第$j$个频率点的第$k$段数据平均值为$$a(j,k) = \frac{1}{L(j)}\sum\limits_{l = 1}^{L(j)} {x\left( {D(j) \cdot (k - 1) + l} \right)}$$ 将该段数据扣除平均值后，以相同长度的窗函数$w(j,l)$对数据段进行加窗，得到预处理的数据段$$\begin{array}{r}G(j,k,l) = \left[ {x\left( {D(j) \cdot (k - 1) + l} \right) - a(j,k)} \right] \cdot w(j,l)\l = 1,2,3…L(j)\end{array}$$ 然后对$G(j,k,l)$进行离散傅里叶变换$$A(j,k) = \sum\limits_{l = 1}^{L(j)} {G(j,k,l) \cdot {e^{ - 2\pi i\frac{m(j)}{L(j)}l} } } $$ 应当注意的是$G(j,k,l)$中$j$表示频率点、$k$表示分段、$l$代表数据在分段内的位置，因此$l$对应傅里叶变换的时间变量。严格来说，上式是离散傅里叶变换第$m(j)$个点的值。其中$$m(j)=\frac{f(j)}{r(j)}$$ 在FFT算法中，$m(j)$应当是整数，而此处不一定满足该要求，故LPSD算法不能利用FFT进行加速，这是该算法耗时较长的原因之一。对$m(j)$的具体讨论详见文献，此处不作赘述。在进行以上操作后，我们得到了第$j$个频率点对应的$K(j)$段数据DFT的$K(j)$个单点值，对这些值进行算数平均，根据Parseval等式可得谱密度为$$P(j) = \frac{C}{K(j)}\sum\limits_{k = 1}^{K(j)} { { {\left| {A(j,k)} \right|}^2} } $$ 其中$C$为归一化系数，由下一节进行讨论。 功率谱的归一化功率谱的归一化系数与窗函数相关，而窗函数可根据不同需求进行不同的选择。对于任意窗函数$w(j,l)$，做如下定义$${S_1}(j) = \sum\limits_{l = 1}^{L(j)} {w(j,l)} \\{S_2}(j) = \sum\limits_{l = 1}^{L(j)} { {w^2}(j,l)} $$ 单边谱的归一化系数可按下式进行计算$${C_{PS} }(j) = \frac{2}{ {S_1^2(j)} }\\{C_{PSD} }(j) = \frac{2}{ { {f_s} \cdot {S_2}(j)} }$$ 其中，$C_{PS}$是功率谱的归一化系数，常用于单频信号的处理。由于绝大多数信号都均匀丰富的频率成分，我们更多地采用功率谱密度，其对于的归一化系数为$C_{PSD}$。以电压为例，功率谱的单位是${\rm V}^2$，而功率谱密度的单位是${\rm V}^2/{\rm Hz}$。在习惯上，我们所说的功率谱值得都是功率谱密度，且取其开方值，单位为${\rm V}^2/\sqrt{ {\rm Hz} }$。至此，我们依据实现的功率谱的求取，以$f(j)$为横轴，$P(j)$为纵轴即可绘制功率谱。 不同算法的对比依然以本文开头的数据为例，周期图法、Welch方法以及LPSD算法得到的功率谱如下图所示。 可见，LPSD算法在低频出有更高的频率分辨率，在高频对谱密度的估计更准确，兼顾了周期图法和Welch方法的优点。然而LPSD算法牺牲了数值计算的速度，在一次利用400万个数据做谱的测试中，各算法的耗时如下。其中iParLPSD是利用了MATLAB并行工具包计算的LPSD算法。 MATLAB源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138% Use LPSD mothod to plot power spectral density% [Pxx,f] = iLPSD(Data,fs,Jdes)% Data --- Input data, it must be column vector% fs --- Sample frequency, unit: Hz% Jdes --- Desired frequency points, default: 1000% Pxx --- One-sided PSD, unit: *^2/Hz% f --- Frequency points related to PSD points, unit: Hz% Default window function is hanning window.% Demo:% iLPSD(data,fs)% Plot PSD using default settings.% h = iLPSD(data,fs,Jdes)% Plot PSD with desired points Jdes% [Pxx,f] = iLPSD(data,fs)% Return PSD points, don't plot any figure% Reference DOI: 10.1016/j.measurement.2005.10.010% XiaoCY 2019-04-10%% Mainfunction varargout = iLPSD(varargin) nargoutchk(0,2); narginchk(2,3); data = varargin&#123;1&#125;; fs = varargin&#123;2&#125;; if nargin == 3 Jdes = varargin&#123;3&#125;; else Jdes = 1000; end Kdes = 100; ksai = 0.5; N = length(data); [f,L,m] = getFreqs(N,fs,Jdes,Kdes,ksai); J = length(f); P = zeros(J,1); for j = 1:J % Use 'parfor' here to enable parallel computation Dj = floor((1-ksai)*L(j)); Kj = floor((N-L(j))/Dj+1); w = hann(L(j)); C_PSD = 2/fs/sum(w.^2); l = (0:L(j)-1)'; W1 = cos(-2*pi*m(j)/L(j).*l); W2 = sin(-2*pi*m(j)/L(j).*l); A = 0; for k = 0:Kj-1 G = data(k*Dj+1:k*Dj+L(j)); G = G-mean(G);% G = detrend(G); G = G.*w; A = A + (G.'*W1)^2+(G.'*W2)^2; end P(j) = A/Kj*C_PSD; end switch nargout case 0 h = PlotPSD(P,f); case 1 h = PlotPSD(P,f); varargout&#123;1&#125; = h; case 2 varargout&#123;1&#125; = P; varargout&#123;2&#125; = f; otherwise % Do Nothing endend%% Subfunctions% get logarithmic frequency pointsfunction [f,L,m] = getFreqs(N,fs,Jdes,Kdes,ksai) fmin = fs/N; fmax = fs/2; r_avg = fs/N*(1+(1-ksai)*(Kdes-1)); g = (N/2)^(1/(Jdes-1))-1; f = zeros(Jdes,1)-1; L = f; m = f; j = 1; fj = fmin; while fj &lt; fmax rj = fj*g; if rj &lt; r_avg rj = sqrt(rj*r_avg); end if rj &lt; fmin rj = fmin; end Lj = floor(fs/rj); rj = fs/Lj; mj = fj/rj; f(j) = fj; L(j) = Lj; m(j) = mj; fj = fj+rj; j = j+1; end f(f&lt;0) = []; L(L&lt;0) = []; m(m&lt;0) = [];end% plot PSDfunction hLine = PlotPSD(P,f) hLine = loglog(f,sqrt(P)); hFig = gcf; hFig.Color = 'w'; hAxes = gca; hAxes.FontSize = 18; hAxes.FontWeight = 'bold'; hAxes.XGrid = 'on'; hAxes.YGrid = 'on'; hAxes.XLabel.String = 'Frequency (Hz)'; hAxes.YLabel.String = 'PSD ([Unit]/Hz^&#123;1/2&#125;)'; hAxes.XLabel.FontSize = 20; hAxes.YLabel.FontSize = 20; hAxes.XLabel.FontWeight = 'bold'; hAxes.YLabel.FontWeight = 'bold'; hLine.LineWidth = 2; end]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>功率谱</tag>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中秋节快乐]]></title>
    <url>%2F2019%2F09%2F13%2FMidAutumn%2F</url>
    <content type="text"><![CDATA[但愿人长久，千里共婵娟。苏轼（水调歌头） 第一次写博客，也不知道该写一些什么，既然今天是中秋节，那就祝大家中秋节快乐吧！ 今天也正好是我两个好朋友的生日，他们是Randy和玉玺。本想着写点什么文艺的话，可是呢，你们懂的。不管怎样，蛋糕还是要吃的，祝你们生日快乐，万事如意！ 今天给翠翠秀我的博客时，他要求我把他也写上，这可真是为难我了，想想，不如就写写“翠翠”这个名字的来源吧。在翠翠成为翠翠之前，我们都以“二哥”来称呼他。那是高中第一次做化学实验的时候，老师一再强调小心轻放不要把玻璃仪器摔坏了，即使如此，也不能阻挡动手能力强的翠翠在一节课的时间内摔坏一个试管和一个容量瓶。课后我们用方言调侃他，叫他“cei cei”。不久，在我们学了《边城》之后，“cei cei”就变成了翠翠。 写的有点乱，既然这样，那再秀一下我女朋友今天做的菜吧，真香。]]></content>
      <categories>
        <category>生活记事</category>
      </categories>
      <tags>
        <tag>闲谈</tag>
      </tags>
  </entry>
</search>
