<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[有意思的数学问题]]></title>
    <url>%2F2020%2F02%2F10%2Fmathgame%2F</url>
    <content type="text"><![CDATA[最近在哔哩哔哩上看到李永乐老师讲股票的一个视频，里边的一个数学问题很有意思，在这里记录一下。 男人和女人的游戏说是有一天，一个男的去酒吧喝酒，然后女服务员就上来找他玩游戏。游戏的规则是： 每个人拿一个硬币，然后同时放到桌面上。如果两个硬币都是正面朝上，女的就给男的3块钱；如果两个硬币都是反面朝上，女的就给男的1块钱；如果两个硬币一正一反，男的就给女的2块钱。 男的一想，如果四种情况都出现一次，正好不赚不亏，就凭运气图个乐子，何况对面还是个漂亮妹子。于是就玩吧。 然而，这个男人却发现自己一直在输钱。我们如何用数学去解释这个问题呢？ 男人的想法现在我们用数学解释下男人输钱的原因。 首先可以判断这个问题属于概率统计，应当用数学期望来评估胜负。以计算男人收益的数学期望为例，如果期望为正，就代表多次游戏后男人平均是胜利的战绩，也就是赚钱；若为负就代表输钱；正好为零就是不赚不亏，这个游戏是公平的。 很多人乍一看，硬币嘛，正反面的概率各占一半，于是男人的受益可以用下面的分布列来表示： 男人\女人 正面(0.5) 反面(0.5) 正面(0.5) +3 -2 反面(0.5) -2 +1 显然有$$E = 3\frac12\frac12 -2 \times (\frac12\frac12+\frac12\frac12) + 1 \times \frac12\frac12 = 0$$所以游戏是公平的。 然而，概率真的是一半一半吗？ 输钱的原因注意审题，硬币是人放在桌面上，而不是随机投掷的，因此可以人为控制概率。我们设男人正面向上的概率为$x$，女人正面向上的概率为$y$。现在的分布列如下： 男人\女人 正面($y$) 反面($1-y$) 正面($x$) +3 -2 反面($1-x$) -2 +1 此时$$E = 3xy - 2\left(x(1-y)+y(1-x)\right) + (1-x)(1-y)= 8xy-3x-3y+1$$要让男人一直输钱，上面的期望就应当使任意$x \in [0,1]$，均有$E&lt;0$，即：$$(8x-3)y&lt;3x-1$$解这个不等式需要进行分类讨论，当$\frac38 &lt; x \le 1$时，$$y&lt;\frac{3x-1}{8x-3} \Rightarrow y&lt;\left(\frac{3x-1}{8x-3}\right){min}=\frac25$$当$0 \le x&lt;\frac38$时，$$y&gt;\frac{3x-1}{8x-3} \Rightarrow y&gt;\left(\frac{3x-1}{8x-3}\right){max}=\frac13$$最后不要忘了验证$x=\frac38$时，$E=-\frac18&lt;0$由此我们可以总结，当$\frac13 &lt; y &lt; \frac25$时，无论$x$取什么值，男人受益的期望总为负值，所以只要玩的次数足够多，男人总是亏的。 结论女人都是大骗子。]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>概率论</tag>
        <tag>李永乐老师</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX学习记录]]></title>
    <url>%2F2020%2F02%2F06%2FLearnLatex%2F</url>
    <content type="text"><![CDATA[最近学习了一下LaTeX，把基本的操作整理成了一个文档，希望和大家分享交流。 原版文档和源码可以在GitHub仓库找到，在这里实在懒得再重复了。 不过我还是将文档转成了图片供大家查看。 欢迎交流，祝大家学习愉快！ PS：最近新型冠状病毒肆虐，小伙伴们要多注意安全啊，祝大家都平安无事！]]></content>
      <categories>
        <category>相见恨晚</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
        <tag>排版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MATLAB函数介绍]]></title>
    <url>%2F2020%2F01%2F15%2FMATLABfcn%2F</url>
    <content type="text"><![CDATA[最近有小伙伴问我说，写程序时有很多复制粘贴的东西，有没有什么办法可以偷懒？所以这里跟大家分享一下MATLAB中最常用的偷懒手段——编写函数。 简介相信大家在写程序的时候会经常遇到一些重复性的操作，一般我们可以通过循环来完成。但有时候这些重复性的操作带有初始条件，这时我们不得不在复制的基础上再将其中某些变量进行修改。这时我们会发现，虽然变量改变了，但是核心的算法并没有改变。或者说输入输出之间的映射没有改变，因此我们可以用一个函数来表征这段算法。 函数定义这里我们只讨论最常用的一些函数的用法。对于面向对象的函数定义，大体相似但略有不同，此处不做介绍。 匿名函数匿名函数适用于一些简短操作的封装，常用于对一些较长的数学表达式进行封装。下面给出了定义匿名函数的一般方法。 1f = @(x) exp(-x.^2/2)/sqrt(2*pi); 可以看到，匿名函数的定义与$y=f(x)$这种形式相似，我们只需要用@和括号给定自变量，然后给出表达式，即可定义名为f的匿名函数。匿名函数必须在使用前进行定义。应当注意的是，有时为了向量化计算，在平方或乘除运算中通常采用加点的运算。 匿名函数还支持多元函数，这种情况下只需要在@(x)中增加变量即可，例如@(x1,x2,x3)。 在老版本中，与匿名函数非常相似的是内联函数，然而得知它在MATLAB以后的版本中将被移除，所以就不介绍了。 函数由于内联函数过于简单，且只在脚本内生效，即无法调用另一个独立脚本中定义的匿名函数。为了使函数能够进行更复杂的操作，且能够被多个脚本所调用，我们需要用function开头定义一个独立的m文件。 函数的格式一般如下所示，例子中&lt;&gt;里边的内容仅为说明，不是代码。 123456789101112% 函数作用的简单说明% 输入输出变量的基本说明% 作者和修改日期%% 主函数function [y1,y2,y3] = simplefcn(x1,x2,x3) &lt;某些操作&gt; y1 = &lt;某变量&gt;; y2 = &lt;某变量&gt;; y3 = &lt;某变量&gt;;end 由于函数的通用性，共同工作的小伙伴们会经常分享一些好用的函数。因此，用%写好注释是一件非常重要的事情。MATLAB官方模板中将函数说明写在function紧接着的下一行，然而更实用的情况是写在文件的最前面，同时我们可以用%%对代码进行分节，使可读性更强。 注释是不参与代码计算的，因此上面这个例子中，函数真正开始于`function’。然后分别给出输出、函数名和输入参数。当有多个输出时，只需用中括号和逗号构成输出向量即可。 函数编写完成后，将其另存为单独的m文件，这时需要文件名与函数名相同。在上面的例子中，对应的函数文件名为应当为simplefcn.m。 同各种其他编程一样，在未申明全局变量的情况下，函数体内的变量与函数外的变量相互独立。这就是说函数内的变量如果与脚本中的变量名字相同，他们并不会相互影响。同时，函数在计算结束后，其内部的变量都会在内存中清除，所以在函数内部计算过程中任何有用的变量都应当考虑将其输出。 子函数有时候我们确实需要像函数一样封装一个较为复杂的代码，但是我们只需要这段代码对当前文件有用，其他文件无法对它进行调用。这时我们就需要子函数来帮忙。不用买关子，子函数实际上就是将函数写在脚本的内部，确切的说(更多情况下)，是写在脚本的末尾。一个简单的例子如下所示。 123456789101112131415161718192021% 脚本说明% 作者和修改日期%% 主代码&lt;某些操作&gt;%% 子函数1% 函数说明% 变量说明function y = subfcn1(x) &lt;某些操作&gt; y = &lt;某变量&gt;;end%% 子函数2% 函数说明% 变量说明function y = subfcn2(x) &lt;某些操作&gt; y = &lt;某变量&gt;;end 同样地，建议将注释写完整并放在前面显眼的位置。例子中，subfcn1和subfcn2是两个子函数，其只在脚本内有效。子函数不仅适用于脚本文件，在大型函数的定义中也可将一些小函数编写成子函数，从而提高代码的可读性。 MATLAB中函数文件以function开头的m文件，除此以外的m文件均可视为脚本。两者的不同之处在于函数可以有输入输出变量，且函数内的变量具有独立的变量空间。而脚本虽然能被其他脚本所调用，但不能提供输入参数，且脚本内的变量共享工作空间。例如两个脚本中都有x这个变量，那么x的值就会受两个脚本控制，有时会因为变量被覆盖而使计算与预期不符。这也是为什么建议将通用的算法写成函数而非脚本， 函数的重载从前面的介绍中可以看到，定义函数时需要给定输入、输出变量的数目，那么问题就来了：如果不确定有多少输入输出，允许函数内使用一定的默认值，或者当给定不同数量的输入、输出时函数进行不同的操作，要怎么做呢？可能有人会说，重新定义相应的函数就可以了。这确实是一种办法，但会使函数文件过多而显得冗余。这时就需要用到函数的重载。 在MATLAB中可利用关键字varargin作为输入，用varargout作为输出来代替可变数量的输入输出(variable-length input/output argument list)。同时，用nargin和nargout来获取输入和输出变量的数量。结合if或switch语句即可实现函数的重载。 进一步，可使用函数narginchk和nargoutchk来限制输入输出变量的数量，但是这两个函数在较老的MATLAB版本中不存在。 这样一来，我们可以给出更加通用的函数定义模板： 123456789101112131415161718192021222324252627282930313233343536373839404142% 函数说明% 变量说明% 作者和修改日期%% 主函数function varargout = fun(varargin) % 解析输入变量 switch nargin case 0 &lt;导入输入变量默认值&gt; case 1 &lt;变量1&gt; = varargin&#123;1&#125;; &lt;其他变量取默认值&gt; otherwise error('无效输入') end % 函数主体 &lt;某些操作&gt; % 解析输出变量 switch nargout &lt;定义不同数量输出时的操作&gt; endend%% 子函数1% 函数说明% 变量说明function y = subfcn1(x) &lt;某些操作&gt; y = &lt;某变量&gt;;end%% 子函数2% 函数说明% 变量说明function y = subfcn2(x) &lt;某些操作&gt; y = &lt;某变量&gt;;end 一般来说，主函数采用可变输入输出以增强通用性，而子函数由于只在文件内部有效，可采用简单的模式。上面以存在两个子函数的情况为例，实际使用时并不一定完全如此。 其他高级用法MATLAB的函数中还有一些其他的”高级”用法，鉴于使用较少且本人也并不常用，这里仅作提醒，有兴趣的伙伴们可以自行学习。 从工作空间获取变量为了与函数内的变量进行交互，常用的方式是在函数内外采用global申明全局变量，从而实现参数传递。 如果仅仅想获取工作区变量而不对其进行操作的话，可采用evalin函数，例如，为了在函数内部获取工作区名为x变量的值，可使用以下代码： 1x = evalin('base','x'); 这样就实现了在不定义全局变量时，从工作空间向函数内部单向传递参数的功能。应当注意，虽然函数内的变量名为x，但由于不是全局变量，其与外部工作空间的x相互独立，除利用该函数传递数值外，互不干扰。 带参数的输入熟悉MATLAB的小伙伴或许知道有些函数可以像面向对象编程那样输入”属性值”，最经典的例子莫过于绘图函数的调用： 1plot(x,y,'LineWidth',2,'LineStyle','--') 上面在调用绘图函数时还额外指定了线宽和线型。像这样的输入，我们应当如何定义函数呢？ 答案是：inputParser。 这个功能的使用稍微复杂一些，平时如果规范编程的话也不常用，所以这里直接给出MATLAB的官方示例，有兴趣的小伙伴可自行学习。 1234567891011121314151617function a = findArea(width,varargin) defaultHeight = 1; defaultUnits = 'inches'; defaultShape = 'rectangle'; expectedShapes = &#123;'square','rectangle','parallelogram'&#125;; p = inputParser; validScalarPosNum = @(x) isnumeric(x) &amp;&amp; isscalar(x) &amp;&amp; (x &gt; 0); addRequired(p,'width',validScalarPosNum); addOptional(p,'height',defaultHeight,validScalarPosNum); addParameter(p,'units',defaultUnits,@isstring); addParameter(p,'shape',defaultShape,... @(x) any(validatestring(x,expectedShapes))); parse(p,width,varargin&#123;:&#125;); a = p.Results.width*p.Results.height; end]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纪念第一次坐飞机]]></title>
    <url>%2F2019%2F12%2F15%2FFirstFlight%2F</url>
    <content type="text"><![CDATA[第一次嘛，总还是得纪念下。 第一次坐飞机，非常激动，看到了平时看不到的景象。要不是时间的限制和刺眼的阳光，我能盯着这片云海看一整天。 想着，第一次坐飞机无论如何也要纪念一下，但是又不知写什么为好，就先这样吧。 有了这么美妙的体验，明天可应当认真工作了，晚安朋友们。]]></content>
      <categories>
        <category>生活记事</category>
      </categories>
      <tags>
        <tag>纪念</tag>
        <tag>飞机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典控制简介]]></title>
    <url>%2F2019%2F11%2F01%2FLearnCtrl%2F</url>
    <content type="text"><![CDATA[控制系统在生活中的应用十分广泛，大到航空航天，小到冰箱空调，都离不开自动控制的影子。在这篇文章里，我尝试对我所理解的控制做一个科普，定性地向大家介绍经典控制理论，希望能够对有兴趣的朋友有所帮助。 简谈经典控制什么是控制?对于这个问题，相信大家在自己的心中都会有很多定性的理解。比如我们可以说：“那个人走钢丝走的很稳，说明他能很好的控制自己的重心；而我，双十一连自己的手都控制不住”。再比如说：“有个逮虾户车开的很稳，下水道漂移时车里的水都不洒出来。”在日常交流中，我们很自觉地把“控制”和“稳”联合在一起使用，想当然地，这两个词之间一定还是有某种联系的。 “控制”，我们可以理解为，当我们向一个系统发出一定的指令时，这个系统能够根据我们的指令做出相应的响应。而“稳定”呢，我们可以说，系统不会受外界干扰而产生不收敛的响应。“控制”和“稳定”联合在一起使用，就是系统既能根据指令所要求的去执行，又不会受到外界的干扰而失控。可以感受到，判定系统稳定性是控制器设计的一个核心目标。 二阶系统的稳定性分析我们不妨从下面这个简单的二阶系统为例来讨论系统的稳定性。 弹簧-质量-阻尼系统，这是生活中最常见、也是最具代表意义的一个二阶系统。从日常的经验来看，如果我们给质量块一个非零的初位移，它将会受弹簧的作用而来回震荡，震荡的幅值会因阻尼的影响而逐渐衰减到零，最终停止在弹簧作用力为零的平衡位置。如果我们把初位移看作是系统的初始扰动，那么显然随着时间的进行，这个扰动会衰减到零，我们可以认为这个系统是稳定的。 另一方面，当我们向质量块施加持续不断的作用力时，换句话说，使质量块进行受迫振动。质量块首先会有自己特定的振动，其由于阻尼衰减而收敛，而外力持续不断，因而质量块最终会受控于外力，我们可以说这个系统是可控的。 从数学上来看，这个二阶系统可以用下面这个线性微分方程来描述：$$m\ddot{x} + c\dot{x} + kx = F$$我们知道，微分方程的解是由通解和特解组成。其中，通解表示的是系统本身的特性，例如该系统所表现的自振；特解表示的是外部输入对系统的影响。当我们输入外力进行控制的时候，我们希望系统由受迫振动来支配，自由振动尽快衰减；当存在外界扰动时，我们不希望自由振动发散。可见，要说系统是稳定的，只要判定系统的自由振动会随着时间衰减（或者至少不发散）。因此，判断系统是否稳定只需要看系统微分方程对应其次方程的通解是否收敛。 上述微分方程对应的齐次方程为：$$m\ddot{x} + c\dot{x} + kx = 0$$如果我们还记得微分方程的特征值解法，我们会设$x=e^{\lambda t}$并代入，可将原微分方程化简为代数方程：$$m\lambda^2 + c\lambda + k = 0$$不失一般性地，我们可以解出两个复数解$\lambda_k = a_k+ib_k (k=1,2)$，因此位移响应为：$$x(t) = C_1 e^{a_1t}(cos(b_1t)+sin(b_1t))+C_2 e^{a_2t}(cos(b_2t)+sin(b_2t))$$由此可见，要使通解不发散，特征值的实部必须小于或等于零。当特征值实部等于零且虚部不为零时，系统的自由响应为等幅振荡，其不发散，可以认为是稳定的；当特征值实部小于零时，自由相应将按照指数包络衰减到零，我们称系统是渐进稳定的。我们说实际系统的稳定一般都是指渐进稳定。 我们顺着这个思路进行推理，对于三阶、四阶甚至更高阶的线性系统，其对应的齐次微分方程会有更多的特征值。显然，任意一个特征值的实部大于零，系统都将因为这个分量的响应发散而失控。因此我们可以给出一个初步的判据：要想使系统稳定，它的所有特征值的实部都应当小于零。 传递函数与稳定性判据既然线性系统都是由线性微分方程来描述的，那么我们就能用拉普拉斯变换将时域转化到频域，这是因为时域的微分方程在频域里为代数方程，这会大大简化分析的难度。 假设某系统的输入是$x$，输出是$y$，它满足以下微分方程：$$y^{(n)} + {a_1}y^{(n)} + … + a_{n - 1}y’ + {a_n} = {b_0}x^{(m)} + {b_1}x^{(m - 1)} + … + b_{m - 1}x’ + {b_m}$$我们对方程两边做拉普拉斯变换，并用大写的$X$和$Y$分别表示输入、输出的拉氏变换，得到：$$\left( { {s^n} + {a_1}{s^{n - 1} } + … + {a_{n - 1} }s + {a_n} } \right)Y = \left( { {b_0}{s^m} + {b_1}{s^{m - 1} } + … + {b_{m - 1} }s + {b_m} } \right)X$$ 没有学过拉氏变换的朋友们不必紧张，因为我们暂且用不到太细致的计算。在这里，我们只需要将原来时域变量从小写变成大写来表示时域到频域的转换，再将$n$次微分改成乘以$s^n$即可（若是$n$次积分就是除以$s^n$）。 传递函数的定义是输出的拉氏变换除以输入的拉氏变换：$$H(s) = \frac{Y}{X} = \frac{ { {b_0}{s^m} + {b_1}{s^{m - 1} } + … + {b_{m - 1} }s + {b_m} } }{ { {s^n} + {a_1}{s^{n - 1} } + … + {a_{n - 1} }s + {a_n} } }$$显然，当多个系统串联是，后一级的输入是前一级的输出，总的传递函数只需要将两个系统的传递函数相乘即可（比微分方程方便多了吧？）。 我们尝试写出上一节所描述的弹簧-质量-阻尼系统的传递函数：$$H_m(s) =\frac{X}{F}= \frac{1}{ms^2+cs+k}$$细心的朋友可能会发现，传递函数的分母正是系统其次方程的特征多项式！根据前面所讨论的利用特征多项式判断系统稳定性的结论，我们可以给出更一般的，基于传递函数的稳定性判据： 系统稳定的充要条件是：传递函数所有极点的实部均小于零 这里的稳定指的是渐近稳定。传递函数的极点是指分母为零时$s$的取值。 经典控制器有了传递函数的概念和稳定性判据后，控制器设计的核心思想就变成了“使用某种手段将系统的极点进行重新配置，使所有极点的实部小于零”。这一节我们将讨论使用最广泛的一种经典控制器：PID（Proportional-Integral-Derivative controller，比例-积分-微分控制器）。 从零到PD再回到我们前面谈到的弹簧-质量-阻尼系统，它的本质是服从牛顿第二定律的，我们不妨用传递函数的概念来看：$$F=m\ddot{x} \rightarrow H_m(s) = \frac{1}{ms^2}$$它的极点等于零，是不稳定的。从另一方面讲，当给定初速度后，在无外力作用下，位移的自由响应将发散到无穷大，说明系统确实不稳定。 然而，增加了弹簧和阻尼后，牛顿第二定律所支配的系统就能稳定下来，这时怎么实现的呢？答：反馈！ 这是非常经典的负反馈：利用位移的增益进行控制，表现为刚度效应，使质量块有往平衡位置收敛的趋势；利用速度的增益进行控制，表现为阻尼效应，使质量块的速度收敛到零，最终使闭环系统稳定。 在实际的工程中，类似的系统有很多，但并不都能有对应的“位移”和“速度”的概念，有些我们甚至不能直接对“速度”进行测量。这时，我们用传感器的输出代表“位移”，利用它的导数代表“速度”，因此，等效的PD控制器就诞生了。 从PD到PID如果我们进一步追究弹簧-质量-阻尼系统的稳态——当输入恒定外力时质量块最终的位置，我们可以将微分方程中各导数置零，表示系统不再随时间变化，达到稳态。容易解出$$x|_{t\rightarrow\inf}=\frac{F}{k} \ne 0$$可见，系统存在所谓的稳态误差。 如何消除系统的稳态误差？或者换个问法：在各种变量都不再随时间改变的稳态下，如何产生一个动态使$x$收敛到零？这时我们不得不利用时间的价值，也就是说，利用输出对时间的积分！ 这样，在PD控制器的基础上增加积分环节，PID就诞生了。 这时，系统的微分方程变为：$$m\ddot{x} = F - (Px + I\int {xdt} + D\dot{x})$$在稳态时，所有变量的导数为零，其中包括：$$\frac{d}{dt}(\int {xdt})=x=0$$说明系统的稳态误差最终会收敛到零位，而最终的反馈力将由I路来支配。 再看系统稳定当系统稳定时，控制器就不再响应，换句话说：系统稳定时，控制器的输入信号（在带宽内）为零。因而控制器可以有下面所示的两种用法。 上图中，控制器的输入就是被控对象（Plant）的输出，稳定时，该信号为零。对于一般的被控对象，这意味着其输入也应当为零，进一步说明反馈的信号应当与输入的信号相抵消。在这种情况下，我们可以实现对信号的闭环测量。 闭环测量的有点有很多，例如，如果被控对象等效为一个具有负刚度的弹簧-质量系统，它将是不稳定的，当有外力作用时其输出发散，无法实现加速度测量，而一旦形成了闭环，就能通过控制器使系统稳定，并利用反馈信号与输入信号相抵消的特性实现测量。 除此之外，闭环的另一个重要优势就是减小被控对象对输入的非线性响应。如果输入过大使被控对象达到非线性，那么开环的输出将存在误差。而在闭环条件下，由于反馈与输入相抵消，被控对象的输入始终保持在非常接近于零的范围内，因此可以避免非线性的影响。 上图展示了闭环控制的另一种使用方法：通过在控制器前将被控对象的输出与参考信号相减，由于稳定时控制器输入为零，这将导致被控对象的输出受参考信号的控制，也就是我们通常所理解的控制。 这种工作模式也很常见，例如家里热得快炸了，那就得开空调，空调就是这种控制模式。这样的优点在于：空调的输出由参考信号决定，而外界扰动可通过控制进行补偿。也就是说，一旦将温度设置在26度，无论刮风下雨还是艳阳天，空调的温度应当始终保持在26度。 闭环控制也有缺点，比如由于引入了控制器，会使结构更加复杂，在设计上造成一定困难；由于增加了器件且处于闭环工作模式下，任意一个器件的损坏将导致整个系统的崩溃；当然，对于一些特殊的被控对象，控制器的参数也不是那么容易获得的。 更多参考对MATLAB/Simulink建模感兴趣的朋友们，可以在我的GitHub仓库找到简单的仿真模型，里面给了一个负刚度弹簧的例子，并介绍了PID参数整定的简单方法。欢迎大家讨论、指教！ 对控制理论感兴趣但没时间详细学习的朋友们，我推荐一个B站大佬，他的视频很精髓，讲解也很好，大家一定会学有所获。]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>控制</tag>
        <tag>自动化</tag>
        <tag>PID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卡尔曼滤波简介]]></title>
    <url>%2F2019%2F10%2F02%2FKalmanFilter%2F</url>
    <content type="text"><![CDATA[卡尔曼滤波器是一种时域的自回归滤波器，能够根据系统的输入输出从噪声中提取状态信息。卡尔曼滤波以其高效的递归特性广泛应用于航空航天等领域。本文对卡尔曼滤波的基本原理进行介绍，并以不太严谨的数学导出其算法结构，旨在帮助初学者快速入门。 基本原理通常我们所说的低通、高通、带通、带阻等滤波器都是所谓的频域滤波器，能对不同频段的信号实现不同的增益或衰减从而只保留关心频段内的信号，可用传递函数或状态空间表示，且通常情况下都是单输入单输出系统(SISO)。这些滤波器不依赖于模型，虽然具有较强的通用性，但却不能根据其它信息对信号做进一步估计。与之不同，卡尔曼滤波器则采用多种输入，并根据模型对系统的状态变量进行估计，是一种时域的数字滤波器。 下面我们从一个最经典的例子开始，来讨论下卡尔曼滤波的基本思想。 有一天你开车出去玩，想时时刻刻知道自己所处的位置以避免迷路，你可以采用两种方式来对当前位置进行估计：其一，利用GPS获取当前位置，这是直接的测量手段；其二，根据车速和上一时刻的位置来对当前位置进行估计，这是根据输入（速度）和模型（运动学）对输出（位置）进行估计。显然，这两种方法都是存在误差（或噪声，以方差或功率谱来定量评估），于是你会想到取两者的平均值作为当前的位置。进一步，你会想到平均值也分为算数平均值、加权平均值、几何平均值等，选用哪种平均值较好呢？由于两种方法的误差不一定相同，所以你会优先选用加权平均值，并且考虑到方差越大表示测量越不准确，所以你以方差的倒数为权。如果你真的想到了这些，那么恭喜你已经触探到了卡尔曼滤波的基本思路。 现在我们对卡尔曼滤波进行归纳和限制，用稍微严谨一点的话来描述：对于线性系统，若系统的各种噪声服从高斯分布，卡尔曼滤波可分为两个步骤：首先利用系统的输入和一定的数学模型对输出进行预测；然后结合实测的输出对状态进行更新。 递归算法现在，我们尝试用简单的数学推导下面框图所示意的卡尔曼滤波的递推算法。再次说明的是，本文采用了基础的数学和类比的思想，原则上并不严谨，但能够对初学者提供一个较为清晰的基础框架，以快速入门并利于后面的学习。推导部分主要参考Understanding the Basis of the Kalman Filter Via a Simple and Intuitive Derivation。 预测首先考虑后向差分算法下，系统的离散时间状态空间表达为$$\begin{array}{l}{\bf{ x} }(i) = A{\bf{ x} }(i - 1) + B{\bf{u} }(i) + {\bf{w}(i) } \\{\bf{y} }(i) = C{\bf{ x} }(i) + D {\bf{u} }(i) + {\bf{v}(i) }\end{array}$$其中$x$为系统的状态变量，$u$为系统输入，$y$为系统输出。在绝大多数情况下，系统的直接传输矩阵$D=0$，因此我们将不讨论它的影响。${\bf{w}(i)}$和${\bf{v}(i)}$为系统中满足高斯分布的噪声，设其均值都为0，协方差矩阵分别为$Q$和$R$。 由于噪声是不可预测的，我们无法对噪声进行建模，故理论模型的开环状态空间方程为$$\begin{array}{l}{\bf{\hat x} }(i) = A{\bf{\hat x} }(i - 1) + B{\bf{u} }(i)\\{\bf{\hat y} }(i) = C{\bf{\hat x} }(i)\end{array}$$应当注意，连续时间和离散时间状态空间的$ABCD$矩阵不一定相等，所以这里采用了不同的记号。戴帽子的${\hat x}$是嵌入模型中状态变量的估计值。 这里借用了Enrico Canuto教授模型嵌入控制中的概念，将卡尔曼滤波器内部的理论模型称之为嵌入模型。 有了嵌入模型，我们就能根据上一时刻的状态和当前时刻的输入计算出当前时刻的理论状态，我们用一个减号上标来表示预测的状态，即$${\bf{\hat x} }^-(i) = A{\bf{\hat x} }(i - 1) + B{\bf{u} }(i)$$前面提到过，状态的修正是根据方差的导数进行加权平均的，因此我们不光要对状态进行估计，还要对状态的方差进行估计。设$i$时刻预测的状态${\bf{\hat x} }^-(i)$的协方差矩阵为$P^-(i)$，修正后的状态${\bf{\hat x} }(i)$的协方差矩阵为$P(i)$，则有$$\begin{array}{l}P^-(i) &amp;=&amp; E \left[ \left( {\bf x}(i) - {\hat {\bf x} }^-(i) \right) \left( {\bf x}(i) - {\hat {\bf x} }^-(i) \right)^T \right] \\&amp;=&amp; E \left[ \left( A \left( {\bf x}(i-1) - {\hat {\bf x} }(i-1) \right) + {\bf w}(i) \right) \left( \left( {\bf x}(i-1) - {\hat {\bf x} }(i-1) \right)^T A^T + {\bf w}^T (i)\right) \right] \\&amp;=&amp; A E \left[ \left( {\bf x}(i-1) - {\hat {\bf x} }(i-1) \right) \left( {\bf x}(i-1) - {\hat {\bf x} }(i-1) \right)^T \right] A^T \\&amp; &amp; + A E \left[\left( {\bf x}(i-1) - {\hat {\bf x} }(i-1) \right) {\bf w}^T (i)\right] \\&amp; &amp; + E \left[ {\bf w}(i) \left( {\bf x}(i-1) - {\hat {\bf x} }(i-1) \right)^T \right] A^T\\&amp; &amp; + E \left( {\bf w}(i) {\bf w}^T (i)\right) \\&amp;=&amp; A P(i-1) A^T + Q\end{array}$$ 上式推导中，由于噪声均值为零，满足$$A E \left[\left( {\bf x}(i-1) - {\hat {\bf x} }(i-1) \right) {\bf w}^T (i)\right] = E \left[ {\bf w}(i) \left( {\bf x}(i-1) - {\hat {\bf x} }(i-1) \right)^T \right] A^T = 0$$ 更新简单起见，我们用一维情况来推导。设预测的输出${\hat y}$以及测得的输出${\tilde y}$分别服从高斯分布$$\begin{array}{l}\hat y \sim N({\mu _1},\sigma _1^2) \Rightarrow {f_1} = \frac{1}{ {\sqrt {2\pi \sigma _1^2} } }{e^{ - \frac{ { { {(y - {\mu _1})}^2} } }{ {2\sigma _1^2} } } }\\\tilde y \sim N({\mu _2},\sigma _2^2) \Rightarrow {f_2} = \frac{1}{ {\sqrt {2\pi \sigma _2^2} } }{e^{ - \frac{ { { {(y - {\mu _2})}^2} } }{ {2\sigma _2^2} } } }\end{array}$$ 对输出最好的估计则是采用两者的联合分布，这可以通过简单地将两者相乘得到。对于服从高斯分布的随机变量，其联合分布仍为高斯分布，因此我们在计算时可以只考虑概率密度函数的核，即忽略归一化系数。$$\begin{array}{l}f_1 f_2 \propto e^{ -\frac{1}{2} \left[ \frac{ (y-\mu_1)^2 }{ \sigma_1^2 } + \frac{ (y-\mu_2)^2 }{ \sigma_2^2 } \right]} \propto e^{ -\frac{ (y-\mu_{fused})^2 }{2 \sigma_{fused}^2} } \\\mu_{fused} = \frac{ \mu_1 \sigma_2^2 + \mu_2 \sigma_1^2 }{\sigma_1^2 + \sigma_2^2} = \frac{\mu_1 \frac{1}{\sigma_1^2} + \mu_2 \frac{1}{\sigma_2^2} }{ \frac{1}{\sigma_1^2} + \frac{1}{\sigma_2^2} } = \mu_1 - \frac{\sigma_1^2}{\sigma_1^2 + \sigma_2^2} \left( \mu_2 - \mu_1 \right) \\\sigma_{fused}^2 = \frac{\sigma_1^2 \sigma_2^2}{\sigma_1^2 + \sigma_2^2} = \sigma_1^2 - \frac{\sigma_1^2}{\sigma_1^2 + \sigma_2^2} \sigma_1^2\end{array}$$ 其中，$\mu_{fused}$的第二个等号说明，对于高斯分布的随机变量，其联合分布的均值的确是各均值按方差的倒数加权取平均得到的。最后的等式形式将用于递归。 卡尔曼滤波器是状态的估计，而上面的修正是对输出的修正，因此需要进行变量替换$$\begin{array}{l}{\mu _1} \to {\bf{\hat y} }(i)\\{\mu _2} \to {\bf{\tilde y} }(i)\\{\mu _{fused} } \to C{\bf{\hat x} }(i)\\\sigma _1^2 \to CP^{-}(i){C^T}\\\sigma _2^2 \to R\\\sigma _{fused}^2 \to CP(i){C^T}\end{array}$$ 代入之后，等号两边同时左乘矩阵$C$的逆，得到状态修正的递推式$$\begin{array}{l}{\bf{\hat x} }(i) = { { {\bf{\hat x} } }^ - }(i) - K\left( { {\bf{\tilde y} }(i) - C{ { {\bf{\hat x} } }^ - }(i)} \right)\\P(i) = {P^ - }(i) - KC{P^ - }(i)\\K = {P^ - }(i){C^T}{\left[ {C{P^ - }(i){C^T} + R} \right]^{ - 1} }\end{array}$$ 其中$K$称为卡尔曼增益。 注意: 矩阵$C$不一定可逆，所以“左乘矩阵$C$的逆”的说法是不准确的，这种表述仅供初学时作为类比。 小结卡尔曼滤波的算法分为两步，首先根据输入和理论模型预测当前状态，用上标带减号的符号表示$${\bf{\hat x} }^-(i) = A{\bf{\hat x} }(i - 1) + B{\bf{u} }(i) \\P^{-}(i) = A P(i-1) A^{T} + Q$$ 然后根据实测的输出对状态进行更新$${\bf{\hat x} }(i) = { { {\bf{\hat x} } }^ - }(i) - K\left( { {\bf{\tilde y} }(i) - C{ { {\bf{\hat x} } }^ - }(i)} \right)\\P(i) = {P^ - }(i) - KC{P^ - }(i)\\K = {P^ - }(i){C^T}{\left[ {C{P^ - }(i){C^T} + R} \right]^{ - 1} }$$ 嗯，这就完了。 仿真测试在第二节的开头给出了我自己在Simulink中搭建的卡尔曼滤波器，卡尔曼增益模块内部构造如下图所示。 构建带有阻尼的简谐振动系统，并设自振周期为1.5s，阻尼比为0.5，质量为1kg。仿真模型顶层设计如下图所示。 导入参数并运行仿真，结果如下。 可以看出该滤波器确实对信号的波动（噪声）有所抑制，深入的分析和评估有待日后进一步学习卡尔曼滤波后与大家分享。 两点感悟离散时间状态空间是由差分近似微分得到的，由于前向差分和后向差分方式的不同，使得表达式会有所差异，表现在结构上如下图所示。 可以隐约感受到，离散状态空间的状态输出，如果是在延时之后（前向差分），就可以利用延时之前的状态进行预测。这种预测可以补偿数字系统采样引入的延时，从而有利于闭环的实时控制。如果输出在延时之前（后向差分），就可以对当前状态进行修正，有利于当前信息的提取。 另一方面，我们关注卡尔曼滤波闭环的反馈端口，其反馈信号直接输给了状态量，而不是常规情况下输给系统的输入段。这容易让我们想到，由于嵌入模型是数学建模获得，它的信息完全可知，并且在程序中我们也可以任意修改。因此，状态观测器的反馈信号不限于反馈到输入端，可以反馈到模型的任何位置。]]></content>
      <categories>
        <category>数据处理</category>
      </categories>
      <tags>
        <tag>卡尔曼</tag>
        <tag>滤波</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git简介]]></title>
    <url>%2F2019%2F09%2F21%2FIntroGit%2F</url>
    <content type="text"><![CDATA[版本控制是对工作中各种文件的变动进行记录、备份，并在有需要的时候进行文件恢复的一种有效手段。Git是最先进的分布式版本控制系统，无论是个人文件的备份，还是大型项目的多人协作，都能从Git中受益匪浅。这篇博客是我个人学习Git的进展记录，目的是汇总Git的常用操作，顺便将Git分享给有兴趣或有需求的朋友们。 邂逅Git相信很多朋友都会或多或少遇到过这些问题：写一篇文章，直接在初稿上改来改去，到最后还是感觉初稿好，却没办法恢复；或者有些习惯很好的朋友，每修改一次就复制一份当前版本作为备份，然而到了后期，工作文件夹内会有一大堆文档，也无法对比各个版本之间的差异。如果你既希望在一个文件上直接修改以保持工作目录的整洁，又想对每个版本进行备注说明，必要时恢复版本进行对比，那么Git就能成为你最得力的助手！ 那么，为了使用Git，首先需要下载安装。对于使用Debian系的Linux的小伙伴们，没有什么比apt-get install git更容易了，别犹豫，一键安装！对于使用Windows系列的小伙伴们，可从Git官方网站 下载安装。基本上按默认配置就可以，一路选“是”。 对于Windows用户，安装时有以下两点需要提醒。其一，在选择Git默认文本编辑器时，默认为Vim，这是一款非常强大的编辑器，但是对新手不是很友好，建议换成其他编辑器，这里比较推荐Notepad++（需另外安装）；其二，在路径环境设置时尽量按推荐使其支持第三方工具调用，这在后期需要GUI界面时提供便利。 Git安装好了之后便可以运行Git Bash，输入git --version，若能显示版本号则表示安装成功。 初识Git为了后面学习的方便，我们需要了解一下Git的三个工作区域：首先，工作目录是指当前能够直接进行操作的目录，例如D:\StudyGit\这个文件夹就可以成为工作目录，我们可以直接对该文件夹内的各种文件进行各种操作；然后，我们会把修改后的文件添加到暂存区，这是临时保存当前工作状态的空间；最后，通过对本次修改添加备注，我们就能把暂存区内的信息提交到Git仓库。一旦数据提交到仓库，我们就不用再担心数据丢失的问题了。 每次提交修改后，Git就会储存当时全部文件的快照，并以一个由40位16进制字符组成的哈希值进行校验。这种哈希值通常看起来像是78b6157cdbc031530c24b003fd72d283fab30d44。通常情况下，我们只需要用前几位数字来表征这一状态，聪明的Git会自己判断。由于Git储存数据的方式，按顺序提交的新的快照指向旧的快照，使得我们的提交历史看起来像下面的图一样。也正因此，我们通常指后提交的快照为“上游”，之前提交的为“下游”。 眼尖的小伙伴应该已经注意到了，图中除了哈希值代表的工作目录快照外，还有master和HEAD两个莫名奇妙的东西。不瞒你说，这俩家伙都是Git内的指针，其中master是Git仓库在初始化时产生的默认分支，其名称并没有特别之处。我们可以说，在Git里，分支就是指针，一个普通的指针就对应一个分支。需要注意的是，另一个全部大写的HEAD是一个非常特殊的指针，它指向当前的分支，换句话说，它决定了你当前的修改会提交在哪个分支。 我们可以打一个非常有意思的比方，我们把文件的提交，或者说仓库的向上游的扩展看作是修路，那么master就代表一个没有包工头的施工队，而HEAD就是包工头（当然是你自己啦）。我们的包工头带领哪个施工队，工程就会在那个施工队的后面延续。而当有多个施工队时，其他的施工队就处于窝工状态。所以我们可以考察下面这种情况，我们在g38jg处新建一个分支，即生成名为joker的指针，再令HEAD指向它，那我们在修改文件提交后，仓库是在A处延续还是在B处呢？ 答案是在A处延续，毕竟包工头HEAD安排的是joker搬砖嘛。 OK，有了这些感性认识之后，后面的学习相信会容易很多。 常用命令本来想着按照教程的思路去解释各种命令，但是廖雪峰的官方网站已经展示了新手向的引导，且Git帮助文档也给出了非常详细的教程。以我的水平，也没必要再在这里赘述，倒不如给出常用的命令列表，再用一个实例进行说明。 下列命令中的&lt;example&gt;均为示例，实际使用时连同尖括号一起替换为相应参数。 非常抱歉地告诉朋友们，下图中“第一次使用前必要的配置”两条命令都被我写错了，但我还是懒得修改图片，直接在这里更正好了： 12git config --global user.name &lt;username&gt;git config --global user.email &lt;email@email.com&gt; Git的分支是杀手锏武器，开发者也非常鼓励大家在使用的时候频繁利用分支进行管理。例如需要进行版本回退时，可以创建个指向回退版本的分支，在那个分支上进行修改，验证可行后将其合并到主分支即可。这就避免了“吃了后悔药之后又后悔”的情况。 一个栗子最近老板让我整理一个系统仿真模型，这个模型不同于我之前搭建的模型，所以我选择新建一个文件夹来专门处理这个事情，同时，我希望用Git对该任务进行管理。我决定采用这种方式进行：以Git的master分支作为主分支，始终保持其正确性，其他所有的任务都在临时的分支中进行，调试完成后再合并到主分支。 工作目录初始化假设这个项目的代号为A，于是我新建了一个名为ProjectA的文件夹，并右键打开Git Bash Here，运行 1git init 虽然Git Bash提示我成功创建了一个仓库，但文件夹内没有看到任何新文件。不要紧，因为之前说过Git仓库不显示在工作目录，实际上它是一个隐藏文件，一般人千万不要去修改它。 接着我打开MATLAB，想到后面的工作会在Simulink上进行，而Simulink在运行时会产生一个名为slprj的文件夹，用来保存仿真过程中的各种信息。我不希望这个文件夹进入Git仓库，所以需要让Git忽略它。为此，我们需要编写一个名为.gitignore的文本文件。 如果你尝试新建txt文件，然后强行改名，Windows会提示你必须键入文件名（它一般不允许以小数点开头的文件）。这时，我们可以先打开notepad++，编辑好内容后保存，这时从提示框内输入以点开头的文件名是可行的，注意不要选任何后缀。对我而言，既然已经打开MATLAB了，直接用MATLAB编辑不就好了嘛。于是我在MATLAB中输入edit .gitignore，在弹出的文件编辑器内输入‘slprj/’后保存。于是Git以后就会忽略这个文件夹了。 又想到，Git可以对文本文件进行对比，并在有差异的地方插入提示符以凸显。然而Simulink模型是二进制文件，如果Git把它当成文本文件对比并修改，我的模型可能就前功尽弃了。因此我要告诉Git哪些文件是二进制文件，在对比差异的时候不要进行修改。所以我又新建了一个名为.gitattributes的文件，在其中添加了以下内容： 123456789101112131415161718192021222324*.mlx -crlf -diff -merge*.mat -crlf -diff -merge*.fig -crlf -diff -merge*.mdl -crlf -diff -merge*.slx -crlf -diff -merge*.mlapp -crlf -diff -merge*.p -crlf -diff -merge*.mdlp -crlf -diff -merge*.slxp -crlf -diff -merge*.sldd -crlf -diff -merge*.slxc -crlf -diff -merge*.mlproj -crlf -diff -merge*.mldatx -crlf -diff -merge*.slreqx -crlf -diff -merge*.sfx -crlf -diff -merge*.sltx -crlf -diff -merge*.mexa64 -crlf -diff -merge*.mexw64 -crlf -diff -merge*.mexmaci64 -crlf -diff -merge*.xlsx -crlf -diff -merge*.docx -crlf -diff -merge*.pdf -crlf -diff -merge*.jpg -crlf -diff -merge*.png -crlf -diff -merge 为了纪念这个开头，我希望将这两个以小数点开头的文件保存到Git仓库，于是我在Git Bash中分别运行了下面两个命令 12git add .git commit -m &apos;Init Git: add configuration&apos; 至此，该项目的初始化配置就完成了。我又用git status命令确认了下当前状态，Bash提示我当前在master分支，工作树很干净，这说明我的操作是正确的。 添加文件并提交修改前期的工作都是最基本的参数录入、函数编写等不容易犯错的事情，并且刚开始还没有形成稳定的版本，所以我决定前期直接在master分支进行工作。第一天，我完成了参数的导入和函数的编写，在下班前，我把这些工作保存到Git仓库。 12git add .git commit -m &apos;load para and design fcn&apos; 同样地，第二天我实现了仿真模型的建立，第三天我获得了初步的控制参数，这些都分别利用add和commit提交到了Git仓库。下班之前，我想看看之前的进展，于是在Git Bash中输入git log --oneline，我看到以下内容 123456chunyu@MyPC /d/iGitHubs/ProjectA (master)$ git log --onelineb483575 (HEAD -&gt; master) get primary ctrl-para3ddb6c9 finish simulink model5752ad5 load para and design fcnd942761 Init Git: add configuration 可见，目前HEAD指针在master分支处，且处于b483575这个快照处，备注说获得了初步的控制参数。至此，我的模型已经基本可用，或者说项目达到了一个初始阶段，后面的工作都可以以此为基准进行，换句话说，后面的工作可以以该处为节点进行分支。 撤销操作第四天起来头脑有点不清醒，我直接在仿真模型中进行修改并尝试更好的参数。没多久，我想起来如果我把参数改乱了，仿真模型就不能用了，这些操作我应该在一个新的分支中进行，所以我需要撤销这些操作，而我又忘记撤销的命令了，于是我在Git Bash中利用git status查看了当前状态，我得到 123456789chunyu@MyPC /d/iGitHubs/ProjectA (master)$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: SimModel.slxno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 它提示我要么用add将修改添加到暂存区，或者用restore放弃修改。于是我用git restore .丢弃了这次的所有操作。 分支管理喝了杯咖啡，头脑清醒些了，于是我用以下命令新建并转到一个名为TunePara的新分支上 1git switch -c TunePara 在新的分支下，我就可以不用担心模型被弄乱，从而为所欲为了。 在接下来几个小时内，我调了很多组不同的参数，虽然可用，但还是没有达到我的预期效果。但我还是将这些过程添加到了Git仓库，现在，我的Git历史看起来是这个样子 12345678910chunyu@MyPC /d/iGitHubs/ProjectA (TunePara)$ git log --oneline294c42d (HEAD -&gt; TunePara) 60Hz Parad003db0 50Hz Paraadaef2f 40Hz Para7e9d9a4 30Hz Parab483575 (master) get primary ctrl-para3ddb6c9 finish simulink model5752ad5 load para and design fcnd942761 Init Git: add configuration 可以看出，我的master分支停留在的b483575这个稳定版本，而TunePara分支已经发展了四次。 这时，老板让我随便用一套参数做一个他临时想到的方案测试。由于参数还没有调到理想状态，我觉得用初始参数去尝试就好。因此，我提交当前工作后，用以下两个命令在b483575处又新建了一个名为SimModel的分支，并切换过去。 12git branch SimModel b483575git switch SimModel 我去？刚刚调参数写的一些新函数全部不见了？不用担心，因为那些函数在TunePara分支上，而现在在SimModel分支，看到的东西当然不太一样了。但是，既然这是另一个分支，我当然也是可以为所欲为的了。 我在SimModel分支提交了一些工作，由于已经有了三个分支，为了清楚地看现在Git的全部历史，我采用了git log --oneline --graph --all命令，然后看到 123456789101112131415chunyu@MyPC /d/iGitHubs/ProjectA (SimModel)$ git log --oneline --graph --all* 64ec543 (HEAD -&gt; SimModel) Exp3* a075106 Exp2* 4b6dbcf Exp1| * 3ce0291 (TunePara) TempBreak to SimModel| * 294c42d 60Hz Para| * d003db0 50Hz Para| * adaef2f 40Hz Para| * 7e9d9a4 30Hz Para|/* b483575 (master) get primary ctrl-para* 3ddb6c9 finish simulink model* 5752ad5 load para and design fcn* d942761 Init Git: add configuration 按照时间顺序的话，我们应当从下往上看。其中，短线表示的是分支，星号表示Git储存的快照，其哈希值在同一行，其后就是当次提交的备注。应当注意的是，如果将该仓库克隆到其他电脑，哈希值可能会变。因此，写好备注是非常重要的。 老板觉得仿真基本达到预期效果，但还是要求参数调好之后重新仿真，因此我又要暂停这个任务，使用git switch TunePara跳转到TunePara分支上继续进行参数设计。 多次尝试后，最终获得了理想的控制参数，那么主分支master就应该向上游推进。也就是说，我们需要将最终完成后的TunePara分支合并到master分支。我们只需要切换到master分支再利用merge命令即可： 12git switch mastergit merge TunePara 然后我们会看到更新完成并有‘Fast-forward’的提醒。再看Git历史 1234567891011121314151617chunyu@MyPC /d/iGitHubs/ProjectA (master)$ git log --oneline --graph --all* 5dec3a7 (HEAD -&gt; master, TunePara) Final Para* 3ce0291 TempBreak to SimModel* 294c42d 60Hz Para* d003db0 50Hz Para* adaef2f 40Hz Para* 7e9d9a4 30Hz Para| * e8faa02 (SimModel) Exp4| * 64ec543 Exp3| * a075106 Exp2| * 4b6dbcf Exp1|/* b483575 get primary ctrl-para* 3ddb6c9 finish simulink model* 5752ad5 load para and design fcn* d942761 Init Git: add configuration 可以看到由于TunePara分支是由之前master分支所在的b483575快照处直接延伸过去的，也就是说从b483575快照到最终的TunePara分支处是一条直线，所以合并时不存在文件冲突，直接快进到上游区，最终使master和TunePara指向同一快照。 至此，我不再需要TunePara分支了，故将其删除。 1git branch -d TunePara 现在，完美的模型在master分支，而仿真需要的其他文件在SimModel分支，为了形成一个新的稳定版本，这两个分支需要合并，我尝试在master分支直接合并SimModel分支的内容： 123456chunyu@MyPC /d/iGitHubs/ProjectA (master)$ git merge SimModelwarning: Cannot merge binary files: Moldel.slx (HEAD vs. SimModel)Auto-merging Moldel.slxCONFLICT (content): Merge conflict in Moldel.slxAutomatic merge failed; fix conflicts and then commit the result. 它说，无法自动合并二进制文件，需要我们手动处理。此时我们如果关注命令行的括号，它已经从(master)变成了(master|MERGING)，说明我们确实需要手动进行合并。这是因为我们在初始化使设置了仿真模型文件作为二进制文件，Git将不会主动修改它。 显然，SimModel分支里的模型是旧的，我们应当保留master分支中的文件，因此我们需要运行 1git checkout Model.slx --ours 最后的--ours代表当前分支的文件，若想采用另一分支的文件，可改用--theirs参数。合并之后不妨用git status查看下状况，Git就会提示这次合并需要输入备注才能提交到Git仓库，因此我们提交本次合并的注释 1git commit -m &apos;merge sim model&apos; 最后看一眼整个历史 12345678910111213141516171819chunyu@MyPC /d/iGitHubs/ProjectA (master)$ git log --oneline --graph --all* 5512a06 (HEAD -&gt; master) merge sim model|\| * e8faa02 (SimModel) Exp4| * 64ec543 Exp3| * a075106 Exp2| * 4b6dbcf Exp1* | 5dec3a7 Final Para* | 3ce0291 TempBreak to SimModel* | 294c42d 60Hz Para* | d003db0 50Hz Para* | adaef2f 40Hz Para* | 7e9d9a4 30Hz Para|/* b483575 get primary ctrl-para* 3ddb6c9 finish simulink model* 5752ad5 load para and design fcn* d942761 Init Git: add configuration 可见，合并后master分支又向上游推进了一步，而SimModel分支保持不变。至此，第一阶段的工作已经完成，用git branch -d SimModel删除多余的分支，等待下一次任务吧。 写在后面在这篇博客写完的时候，本人对Git的使用也不到一个月的时间，故其中难免有不周全的地方。对Git有兴趣的同学可以阅读Git官方提供的参考书Pro Git或直接阅读Git帮助文档。祝大家学习愉快！]]></content>
      <categories>
        <category>相见恨晚</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LPSD功率谱估计]]></title>
    <url>%2F2019%2F09%2F18%2FLPSD%2F</url>
    <content type="text"><![CDATA[欧洲航空局（ESA）为LISA计划设计了完整的数据处理工具包LTPDA （LISA Technology Package Data Analysis），该工具包中内置一种对数频率点功率谱估计算法，即本文所提的LPSD算法。该算法由文献Improved spectrum estimation from digitized time series on a logarithmic frequency axis 给出。本文作为对该文献学习的总结，同时作为对MATLAB的学习，自编了基于LPSD算法的功率谱估计函数。 常用功率谱估计算法功率谱估计是频域分析的一种常用手段，可用来检测信号中的单频信号或评估仪器的噪声本底等。常用的功率谱估计算法有周期图法（对应MATLAB函数为periofogram）和Welch方法（pwelch）。对于采集系统收集到的数字信号，周期图法会对该数据进行去漂（detrend）和加窗，然后利用快速傅里叶变换（FFT，是DFT的快速算法）将信号转化到频域$$X(k) = \sum\limits_{n = 0}^{N - 1} {x(n){e^{ - i\frac{ {2\pi} } {N}nk}}}$$ 最后利用Parseval等式获得功率谱$$S(k) = \frac{2}{Nf_s}|X(k)|^2$$ 式中，系数2是将双边谱转换到单边谱，这是因为负频率不具备实际的物理意义。Welch方法相对于周期图法增加了分段平均的思想，其将数据等分为多段，并且允许各段数据之间具有一定的重叠率以补偿窗函数引入的数据不平权的影响。对每段数据采用周期图法，最后将各段分别计算的功率谱进算数平均，获得最终的谱估计值。图中展示了周期图法和Welch方法对功率谱估计的结果。其中，蓝色曲线的周期图法一次性使用了全部的数据，因而有最高的频率分辨率，可以看到更低的频带。但是其高频部分的数据波动较大，且波动范围不会随着点数的增加而减小，即不满足所谓的一致性原则。橙色的Welch算法由于对数据进行了分段，直接进行FFT的数据相对较少，导致频率分辨率降低。但是分段平均使得高频波动的幅值大大减小，可以证明波动会随着分段次数的增加而进一步减小。 LPSD算法LPSD算法的基本思想是采用对数分布的频率点，由于此时频率点的差值不是定值，即DFT的频率分辨率随频率点变化，因而在求取每个频率点对应的功率谱密度时应当对原始数据进行不同的分段。这就是说，LPSD算法的每个频率点对应于不同分段次数下Welch算法中的相应点。 对数频率的选取记采集到的离散数据为$x(n),n=0,1,2…N-1$，采样率为$f_s$。假设希望计算$J_{des}$个点，其中第$j$个点对应的频率为$f(j)$、功率谱密度为$P(j)$、频率分辨率为$r(j)=f(j+1)-f(j)$。应当注意的是，这里的频率分辨率是指计算DFT的频率点之间的间隔，更一般的说法应当是栅栏效应。有限长数据的频率分辨率实际由DTFT定义，与数据的时间长度互为导数，本文中称之为最小分辨率。在LPSD算法中不能采用logspace生成对数分布的频率点，因为数值计算的频率间隔不应当小于最小分辨率$r_{min}$，否则这种计算是没有意义的。为了计算频率点，首先考察严格对数均匀的频率点应当满足$$\log f(j + 1) - \log f(j) = C$$其中C为常数。频率范围受分辨率和采样率的影响，取$$f(1)=r_{min}=\frac{f_s}{N},f(J_{des})=f_{max}=\frac{f_s}{2}$$再令$$g=\log f_{max}- \log r_{min}=\log \frac{N}{2}$$ 可以得到第$j$个点的频率和频率分辨率分别为$$f(j)=r_{min} \times 10^{\frac{j-1}{J_{des}-1}g} \\ r_0(j)=f(j)(10^{\frac{g}{J_{des}-1}}-1)$$ 为了使低频段到高频段的频率分辨率变化较连续，对中频段对应的频率分辨率进行调整，为此，引入分段次数期望值$K_{des}$（其典型值为100），在分段重叠率为$\xi$时满足$$({K_{des}} - 1)(1 - \xi ){L_{avg}} + {L_{avg}} = N$$ 此时对应的频率分辨率为$$r_{avg}=\frac{f_s}{L_{avg}}=\frac{f_s}{N}[ (K_{des}-1)(1-\xi) +1 ]$$ 根据分辨率限制和算法需求，我们需要对频率分辨率进行调整，如下$$r’(j) = {\begin{array}{|cc}r_0(j) &amp; ,r_0(j)\ge r_{avg} \\\sqrt{r_0(j) \cdot r_{avg}} &amp; ,r_0(j) &lt; r_{avg}{\rm{ and }}\sqrt{r_0(j) \cdot r_{avg}} &gt; r_{\min } \\r_{min} &amp; ,else \\\end{array}}$$ 除此之外，为了保证依据频率分辨率分段的数据长度为整数，频率分辨率还应当做进一步调整$$L(j) = \left\lfloor{\frac{f_s}{r’(j)}} \right\rfloor \\ r(j) = \frac{f_s}{L(j)}$$ 其中，符号$\left\lfloor \right\rfloor$表示向下取整。综上所述，对数频率的选取算法为：以$f(1)=r_{min}$为起点，根据频率和$J_{des}$求解分辨率$r_0(j)$，并根据要求对分辨率进行调整，得到$r(j)$，接着利用$f(j+1)=f(j)+r(j)$进行迭代。当计算的频率达到奈奎斯特频率即可停止迭代。值得注意的是，由于对频率分辨率进行了修正，获得的频率点并不是严格的对数分布，同时也会导致实际获得的频率点$J$与期望的点数$J_{des}$并不相等。 数据的分段处理对于第$j$个频率点，由前可知其频率分辨率为$r(j)$，分段后的每段数据长度为$L(j)$。为了减小窗函数导致的数据不等权，允许分段之间存在一定的重叠率$\xi$，数据分段如下图所示。由图可知，每段数据未重叠部分长度为$$D(j) = (1 - \xi ) \cdot L(j)$$ 因而分段次数为$$K(j) = \left\lfloor {\frac{N - L(j)} {D(j) + 1} } \right\rfloor $$ 针对每段数据，我们可以选择利用mean函数求取数据平均值后予以扣除，或利用detrend函数直接去除数据中线性漂移。以扣除平均值为例，第$j$个频率点的第$k$段数据平均值为$$a(j,k) = \frac{1}{L(j)}\sum\limits_{l = 1}^{L(j)} {x\left( {D(j) \cdot (k - 1) + l} \right)}$$ 将该段数据扣除平均值后，以相同长度的窗函数$w(j,l)$对数据段进行加窗，得到预处理的数据段$$\begin{array}{r}G(j,k,l) = \left[ {x\left( {D(j) \cdot (k - 1) + l} \right) - a(j,k)} \right] \cdot w(j,l)\l = 1,2,3…L(j)\end{array}$$ 然后对$G(j,k,l)$进行离散傅里叶变换$$A(j,k) = \sum\limits_{l = 1}^{L(j)} {G(j,k,l) \cdot {e^{ - 2\pi i\frac{m(j)}{L(j)}l} } } $$ 应当注意的是$G(j,k,l)$中$j$表示频率点、$k$表示分段、$l$代表数据在分段内的位置，因此$l$对应傅里叶变换的时间变量。严格来说，上式是离散傅里叶变换第$m(j)$个点的值。其中$$m(j)=\frac{f(j)}{r(j)}$$ 在FFT算法中，$m(j)$应当是整数，而此处不一定满足该要求，故LPSD算法不能利用FFT进行加速，这是该算法耗时较长的原因之一。对$m(j)$的具体讨论详见文献，此处不作赘述。在进行以上操作后，我们得到了第$j$个频率点对应的$K(j)$段数据DFT的$K(j)$个单点值，对这些值进行算数平均，根据Parseval等式可得谱密度为$$P(j) = \frac{C}{K(j)}\sum\limits_{k = 1}^{K(j)} { { {\left| {A(j,k)} \right|}^2} } $$ 其中$C$为归一化系数，由下一节进行讨论。 功率谱的归一化功率谱的归一化系数与窗函数相关，而窗函数可根据不同需求进行不同的选择。对于任意窗函数$w(j,l)$，做如下定义$${S_1}(j) = \sum\limits_{l = 1}^{L(j)} {w(j,l)} \\{S_2}(j) = \sum\limits_{l = 1}^{L(j)} { {w^2}(j,l)} $$ 单边谱的归一化系数可按下式进行计算$${C_{PS} }(j) = \frac{2}{ {S_1^2(j)} }\\{C_{PSD} }(j) = \frac{2}{ { {f_s} \cdot {S_2}(j)} }$$ 其中，$C_{PS}$是功率谱的归一化系数，常用于单频信号的处理。由于绝大多数信号都均匀丰富的频率成分，我们更多地采用功率谱密度，其对于的归一化系数为$C_{PSD}$。以电压为例，功率谱的单位是${\rm V}^2$，而功率谱密度的单位是${\rm V}^2/{\rm Hz}$。在习惯上，我们所说的功率谱值得都是功率谱密度，且取其开方值，单位为${\rm V}^2/\sqrt{ {\rm Hz} }$。至此，我们依据实现的功率谱的求取，以$f(j)$为横轴，$P(j)$为纵轴即可绘制功率谱。 不同算法的对比依然以本文开头的数据为例，周期图法、Welch方法以及LPSD算法得到的功率谱如下图所示。 可见，LPSD算法在低频出有更高的频率分辨率，在高频对谱密度的估计更准确，兼顾了周期图法和Welch方法的优点。然而LPSD算法牺牲了数值计算的速度，在一次利用400万个数据做谱的测试中，各算法的耗时如下。其中iParLPSD是利用了MATLAB并行工具包计算的LPSD算法。 MATLAB源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138% Use LPSD mothod to plot power spectral density% [Pxx,f] = iLPSD(Data,fs,Jdes)% Data --- Input data, it must be column vector% fs --- Sample frequency, unit: Hz% Jdes --- Desired frequency points, default: 1000% Pxx --- One-sided PSD, unit: *^2/Hz% f --- Frequency points related to PSD points, unit: Hz% Default window function is hanning window.% Demo:% iLPSD(data,fs)% Plot PSD using default settings.% h = iLPSD(data,fs,Jdes)% Plot PSD with desired points Jdes% [Pxx,f] = iLPSD(data,fs)% Return PSD points, don't plot any figure% Reference DOI: 10.1016/j.measurement.2005.10.010% XiaoCY 2019-04-10%% Mainfunction varargout = iLPSD(varargin) nargoutchk(0,2); narginchk(2,3); data = varargin&#123;1&#125;; fs = varargin&#123;2&#125;; if nargin == 3 Jdes = varargin&#123;3&#125;; else Jdes = 1000; end Kdes = 100; ksai = 0.5; N = length(data); [f,L,m] = getFreqs(N,fs,Jdes,Kdes,ksai); J = length(f); P = zeros(J,1); for j = 1:J % Use 'parfor' here to enable parallel computation Dj = floor((1-ksai)*L(j)); Kj = floor((N-L(j))/Dj+1); w = hann(L(j)); C_PSD = 2/fs/sum(w.^2); l = (0:L(j)-1)'; W1 = cos(-2*pi*m(j)/L(j).*l); W2 = sin(-2*pi*m(j)/L(j).*l); A = 0; for k = 0:Kj-1 G = data(k*Dj+1:k*Dj+L(j)); G = G-mean(G);% G = detrend(G); G = G.*w; A = A + (G.'*W1)^2+(G.'*W2)^2; end P(j) = A/Kj*C_PSD; end switch nargout case 0 h = PlotPSD(P,f); case 1 h = PlotPSD(P,f); varargout&#123;1&#125; = h; case 2 varargout&#123;1&#125; = P; varargout&#123;2&#125; = f; otherwise % Do Nothing endend%% Subfunctions% get logarithmic frequency pointsfunction [f,L,m] = getFreqs(N,fs,Jdes,Kdes,ksai) fmin = fs/N; fmax = fs/2; r_avg = fs/N*(1+(1-ksai)*(Kdes-1)); g = (N/2)^(1/(Jdes-1))-1; f = zeros(Jdes,1)-1; L = f; m = f; j = 1; fj = fmin; while fj &lt; fmax rj = fj*g; if rj &lt; r_avg rj = sqrt(rj*r_avg); end if rj &lt; fmin rj = fmin; end Lj = floor(fs/rj); rj = fs/Lj; mj = fj/rj; f(j) = fj; L(j) = Lj; m(j) = mj; fj = fj+rj; j = j+1; end f(f&lt;0) = []; L(L&lt;0) = []; m(m&lt;0) = [];end% plot PSDfunction hLine = PlotPSD(P,f) hLine = loglog(f,sqrt(P)); hFig = gcf; hFig.Color = 'w'; hAxes = gca; hAxes.FontSize = 18; hAxes.FontWeight = 'bold'; hAxes.XGrid = 'on'; hAxes.YGrid = 'on'; hAxes.XLabel.String = 'Frequency (Hz)'; hAxes.YLabel.String = 'PSD ([Unit]/Hz^&#123;1/2&#125;)'; hAxes.XLabel.FontSize = 20; hAxes.YLabel.FontSize = 20; hAxes.XLabel.FontWeight = 'bold'; hAxes.YLabel.FontWeight = 'bold'; hLine.LineWidth = 2; end]]></content>
      <categories>
        <category>数据处理</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>功率谱</tag>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中秋节快乐]]></title>
    <url>%2F2019%2F09%2F13%2FMidAutumn%2F</url>
    <content type="text"><![CDATA[但愿人长久，千里共婵娟。苏轼（水调歌头） 第一次写博客，也不知道该写一些什么，既然今天是中秋节，那就祝大家中秋节快乐吧！ 今天也正好是我两个好朋友的生日，他们是Randy和玉玺。本想着写点什么文艺的话，可是呢，你们懂的。不管怎样，蛋糕还是要吃的，祝你们生日快乐，万事如意！ 今天给翠翠秀我的博客时，他要求我把他也写上，这可真是为难我了，想想，不如就写写“翠翠”这个名字的来源吧。在翠翠成为翠翠之前，我们都以“二哥”来称呼他。那是高中第一次做化学实验的时候，老师一再强调小心轻放不要把玻璃仪器摔坏了，即使如此，也不能阻挡动手能力强的翠翠在一节课的时间内摔坏一个试管和一个容量瓶。课后我们用方言调侃他，叫他“cei cei”。不久，在我们学了《边城》之后，“cei cei”就变成了翠翠。 写的有点乱，既然这样，那再秀一下我女朋友今天做的菜吧，真香。]]></content>
      <categories>
        <category>生活记事</category>
      </categories>
      <tags>
        <tag>闲谈</tag>
      </tags>
  </entry>
</search>
