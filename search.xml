<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[卡尔曼滤波简介]]></title>
    <url>%2F2019%2F10%2F02%2FKalmanFilter%2F</url>
    <content type="text"><![CDATA[卡尔曼滤波器是一种时域的自回归滤波器，能够根据系统的输入输出从噪声中提取状态信息。卡尔曼滤波以其高效的递归特性广泛应用于航空航天等领域。本文对卡尔曼滤波的基本原理进行介绍，并以不太严谨的数学导出其算法结构，旨在帮助初学者快速入门。 基本原理通常我们所说的低通、高通、带通、带阻等滤波器都是所谓的频域滤波器，能对不同频段的信号实现不同的增益或衰减从而只保留关心频段内的信号，可用传递函数或状态空间表示，且通常情况下都是单输入单输出系统(SISO)。这些滤波器不依赖于模型，虽然具有较强的通用性，但却不能根据其它信息对信号做进一步估计。与之不同，卡尔曼滤波器则采用多种输入，并根据模型对系统的状态变量进行估计，是一种时域的数字滤波器。 下面我们从一个最经典的例子开始，来讨论下卡尔曼滤波的基本思想。 有一天你开车出去玩，想时时刻刻知道自己所处的位置以避免迷路，你可以采用两种方式来对当前位置进行估计：其一，利用GPS获取当前位置，这是直接的测量手段；其二，根据车速和上一时刻的位置来对当前位置进行估计，这是根据输入（速度）和模型（运动学）对输出（位置）进行估计。显然，这两种方法都是存在误差（或噪声，以方差或功率谱来定量评估），于是你会想到取两者的平均值作为当前的位置。进一步，你会想到平均值也分为算数平均值、加权平均值、几何平均值等，选用哪种平均值较好呢？由于两种方法的误差不一定相同，所以你会优先选用加权平均值，并且考虑到方差越大表示测量越不准确，所以你以方差的倒数为权。如果你真的想到了这些，那么恭喜你已经触探到了卡尔曼滤波的基本思路。 现在我们对卡尔曼滤波进行归纳和限制，用稍微严谨一点的话来描述：对于线性系统，若系统的各种噪声服从高斯分布，卡尔曼滤波可分为两个步骤：首先利用系统的输入和一定的数学模型对输出进行预测；然后结合实测的输出对状态进行更新。 递归算法现在，我们尝试用简单的数学推导下面框图所示意的卡尔曼滤波的递推算法。再次说明的是，本文采用了基础的数学和类比的思想，原则上并不严谨，但能够对初学者提供一个较为清晰的基础框架，以快速入门并利于后面的学习。推导部分主要参考Understanding the Basis of the Kalman Filter Via a Simple and Intuitive Derivation。 预测首先考虑后向差分算法下，系统的离散时间状态空间表达为$$\begin{array}{l}{\bf{ x} }(i) = A{\bf{ x} }(i - 1) + B{\bf{u} }(i) + {\bf{w}(i) } \\{\bf{y} }(i) = C{\bf{ x} }(i) + D {\bf{u} }(i) + {\bf{v}(i) }\end{array}$$其中$x$为系统的状态变量，$u$为系统输入，$y$为系统输出。在绝大多数情况下，系统的直接传输矩阵$D=0$，因此我们将不讨论它的影响。${\bf{w}(i)}$和${\bf{v}(i)}$为系统中满足高斯分布的噪声，设其均值都为0，协方差矩阵分别为$Q$和$R$。 由于噪声是不可预测的，我们无法对噪声进行建模，故理论模型的开环状态空间方程为$$\begin{array}{l}{\bf{\hat x} }(i) = A{\bf{\hat x} }(i - 1) + B{\bf{u} }(i)\\{\bf{\hat y} }(i) = C{\bf{\hat x} }(i)\end{array}$$应当注意，连续时间和离散时间状态空间的$ABCD$矩阵不一定相等，所以这里采用了不同的记号。戴帽子的${\hat x}$是嵌入模型中状态变量的估计值。 这里借用了Enrico Canuto教授模型嵌入控制中的概念，将卡尔曼滤波器内部的理论模型称之为嵌入模型。 有了嵌入模型，我们就能根据上一时刻的状态和当前时刻的输入计算出当前时刻的理论状态，我们用一个减号上标来表示预测的状态，即$${\bf{\hat x} }^-(i) = A{\bf{\hat x} }(i - 1) + B{\bf{u} }(i)$$前面提到过，状态的修正是根据方差的导数进行加权平均的，因此我们不光要对状态进行估计，还要对状态的方差进行估计。设$i$时刻预测的状态${\bf{\hat x} }^-(i)$的协方差矩阵为$P^-(i)$，修正后的状态${\bf{\hat x} }(i)$的协方差矩阵为$P(i)$，则有$$\begin{array}{l}P^-(i) &amp;=&amp; E \left[ \left( {\bf x}(i) - {\hat {\bf x} }^-(i) \right) \left( {\bf x}(i) - {\hat {\bf x} }^-(i) \right)^T \right] \\&amp;=&amp; E \left[ \left( A \left( {\bf x}(i-1) - {\hat {\bf x} }(i-1) \right) + {\bf w}(i) \right) \left( \left( {\bf x}(i-1) - {\hat {\bf x} }(i-1) \right)^T A^T + {\bf w}^T (i)\right) \right] \\&amp;=&amp; A E \left[ \left( {\bf x}(i-1) - {\hat {\bf x} }(i-1) \right) \left( {\bf x}(i-1) - {\hat {\bf x} }(i-1) \right)^T \right] A^T \\&amp; &amp; + A E \left[\left( {\bf x}(i-1) - {\hat {\bf x} }(i-1) \right) {\bf w}^T (i)\right] \\&amp; &amp; + E \left[ {\bf w}(i) \left( {\bf x}(i-1) - {\hat {\bf x} }(i-1) \right)^T \right] A^T\\&amp; &amp; + E \left( {\bf w}(i) {\bf w}^T (i)\right) \\&amp;=&amp; A P(i-1) A^T + Q\end{array}$$ 上式推导中，由于噪声均值为零，满足$$A E \left[\left( {\bf x}(i-1) - {\hat {\bf x} }(i-1) \right) {\bf w}^T (i)\right] = E \left[ {\bf w}(i) \left( {\bf x}(i-1) - {\hat {\bf x} }(i-1) \right)^T \right] A^T = 0$$ 更新简单起见，我们用一维情况来推导。设预测的输出${\hat y}$以及测得的输出${\tilde y}$分别服从高斯分布$$\begin{array}{l}\hat y \sim N({\mu _1},\sigma _1^2) \Rightarrow {f_1} = \frac{1}{ {\sqrt {2\pi \sigma _1^2} } }{e^{ - \frac{ { { {(y - {\mu _1})}^2} } }{ {2\sigma _1^2} } } }\\\tilde y \sim N({\mu _2},\sigma _2^2) \Rightarrow {f_2} = \frac{1}{ {\sqrt {2\pi \sigma _2^2} } }{e^{ - \frac{ { { {(y - {\mu _2})}^2} } }{ {2\sigma _2^2} } } }\end{array}$$ 对输出最好的估计则是采用两者的联合分布，这可以通过简单地将两者相乘得到。对于服从高斯分布的随机变量，其联合分布仍为高斯分布，因此我们在计算时可以只考虑概率密度函数的核，即忽略归一化系数。$$\begin{array}{l}f_1 f_2 \propto e^{ -\frac{1}{2} \left[ \frac{ (y-\mu_1)^2 }{ \sigma_1^2 } + \frac{ (y-\mu_2)^2 }{ \sigma_2^2 } \right]} \propto e^{ -\frac{ (y-\mu_{fused})^2 }{2 \sigma_{fused}^2} } \\\mu_{fused} = \frac{ \mu_1 \sigma_2^2 + \mu_2 \sigma_1^2 }{\sigma_1^2 + \sigma_2^2} = \frac{\mu_1 \frac{1}{\sigma_1^2} + \mu_2 \frac{1}{\sigma_2^2} }{ \frac{1}{\sigma_1^2} + \frac{1}{\sigma_2^2} } = \mu_1 - \frac{\sigma_1^2}{\sigma_1^2 + \sigma_2^2} \left( \mu_2 - \mu_1 \right) \\\sigma_{fused}^2 = \frac{\sigma_1^2 \sigma_2^2}{\sigma_1^2 + \sigma_2^2} = \sigma_1^2 - \frac{\sigma_1^2}{\sigma_1^2 + \sigma_2^2} \sigma_1^2\end{array}$$ 其中，$\mu_{fused}$的第二个等号说明，对于高斯分布的随机变量，其联合分布的均值的确是各均值按方差的倒数加权取平均得到的。最后的等式形式将用于递归。 卡尔曼滤波器是状态的估计，而上面的修正是对输出的修正，因此需要进行变量替换$$\begin{array}{l}{\mu _1} \to {\bf{\hat y} }(i)\\{\mu _2} \to {\bf{\tilde y} }(i)\\{\mu _{fused} } \to C{\bf{\hat x} }(i)\\\sigma _1^2 \to CP^{-}(i){C^T}\\\sigma _2^2 \to R\\\sigma _{fused}^2 \to CP(i){C^T}\end{array}$$ 代入之后，等号两边同时左乘矩阵$C$的逆，得到状态修正的递推式$$\begin{array}{l}{\bf{\hat x} }(i) = { { {\bf{\hat x} } }^ - }(i) - K\left( { {\bf{\tilde y} }(i) - C{ { {\bf{\hat x} } }^ - }(i)} \right)\\P(i) = {P^ - }(i) - KC{P^ - }(i)\\K = {P^ - }(i){C^T}{\left[ {C{P^ - }(i){C^T} + R} \right]^{ - 1} }\end{array}$$ 其中$K$称为卡尔曼增益。 注意: 矩阵$C$不一定可逆，所以“左乘矩阵$C$的逆”的说法是不准确的，这种表述仅供初学时作为类比。 小结卡尔曼滤波的算法分为两步，首先根据输入和理论模型预测当前状态，用上标带减号的符号表示$${\bf{\hat x} }^-(i) = A{\bf{\hat x} }(i - 1) + B{\bf{u} }(i) \\P^{-}(i) = A P(i-1) A^{T} + Q$$ 然后根据实测的输出对状态进行更新$${\bf{\hat x} }(i) = { { {\bf{\hat x} } }^ - }(i) - K\left( { {\bf{\tilde y} }(i) - C{ { {\bf{\hat x} } }^ - }(i)} \right)\\P(i) = {P^ - }(i) - KC{P^ - }(i)\\K = {P^ - }(i){C^T}{\left[ {C{P^ - }(i){C^T} + R} \right]^{ - 1} }$$ 嗯，这就完了。 仿真测试在第二节的开头给出了我自己在Simulink中搭建的卡尔曼滤波器，卡尔曼增益模块内部构造如下图所示。 构建带有阻尼的简谐振动系统，并设自振周期为1.5s，阻尼比为0.5，质量为1kg。仿真模型顶层设计如下图所示。 导入参数并运行仿真，结果如下。 可以看出该滤波器确实对信号的波动（噪声）有所抑制，深入的分析和评估有待日后进一步学习卡尔曼滤波后与大家分享。 两点感悟离散时间状态空间是由差分近似微分得到的，由于前向差分和后向差分方式的不同，使得表达式会有所差异，表现在结构上如下图所示。 可以隐约感受到，离散状态空间的状态输出，如果是在延时之后（前向差分），就可以利用延时之前的状态进行预测。这种预测可以补偿数字系统采样引入的延时，从而有利于闭环的实时控制。如果输出在延时之前（后向差分），就可以对当前状态进行修正，有利于当前信息的提取。 另一方面，我们关注卡尔曼滤波闭环的反馈端口，其反馈信号直接输给了状态量，而不是常规情况下输给系统的输入段。这容易让我们想到，由于嵌入模型是数学建模获得，它的信息完全可知，并且在程序中我们也可以任意修改。因此，状态观测器的反馈信号不限于反馈到输入端，可以反馈到模型的任何位置。]]></content>
      <categories>
        <category>数据处理</category>
      </categories>
      <tags>
        <tag>卡尔曼</tag>
        <tag>滤波</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git简介]]></title>
    <url>%2F2019%2F09%2F21%2FIntroGit%2F</url>
    <content type="text"><![CDATA[版本控制是对工作中各种文件的变动进行记录、备份，并在有需要的时候进行文件恢复的一种有效手段。Git是最先进的分布式版本控制系统，无论是个人文件的备份，还是大型项目的多人协作，都能从Git中受益匪浅。这篇博客是我个人学习Git的进展记录，目的是汇总Git的常用操作，顺便将Git分享给有兴趣或有需求的朋友们。 邂逅Git相信很多朋友都会或多或少遇到过这些问题：写一篇文章，直接在初稿上改来改去，到最后还是感觉初稿好，却没办法恢复；或者有些习惯很好的朋友，每修改一次就复制一份当前版本作为备份，然而到了后期，工作文件夹内会有一大堆文档，也无法对比各个版本之间的差异。如果你既希望在一个文件上直接修改以保持工作目录的整洁，又想对每个版本进行备注说明，必要时恢复版本进行对比，那么Git就能成为你最得力的助手！ 那么，为了使用Git，首先需要下载安装。对于使用Debian系的Linux的小伙伴们，没有什么比apt-get install git更容易了，别犹豫，一键安装！对于使用Windows系列的小伙伴们，可从Git官方网站 下载安装。基本上按默认配置就可以，一路选“是”。 对于Windows用户，安装时有以下两点需要提醒。其一，在选择Git默认文本编辑器时，默认为Vim，这是一款非常强大的编辑器，但是对新手不是很友好，建议换成其他编辑器，这里比较推荐Notepad++（需另外安装）；其二，在路径环境设置时尽量按推荐使其支持第三方工具调用，这在后期需要GUI界面时提供便利。 Git安装好了之后便可以运行Git Bash，输入git --version，若能显示版本号则表示安装成功。 初识Git为了后面学习的方便，我们需要了解一下Git的三个工作区域：首先，工作目录是指当前能够直接进行操作的目录，例如D:\StudyGit\这个文件夹就可以成为工作目录，我们可以直接对该文件夹内的各种文件进行各种操作；然后，我们会把修改后的文件添加到暂存区，这是临时保存当前工作状态的空间；最后，通过对本次修改添加备注，我们就能把暂存区内的信息提交到Git仓库。一旦数据提交到仓库，我们就不用再担心数据丢失的问题了。 每次提交修改后，Git就会储存当时全部文件的快照，并以一个由40位16进制字符组成的哈希值进行校验。这种哈希值通常看起来像是78b6157cdbc031530c24b003fd72d283fab30d44。通常情况下，我们只需要用前几位数字来表征这一状态，聪明的Git会自己判断。由于Git储存数据的方式，按顺序提交的新的快照指向旧的快照，使得我们的提交历史看起来像下面的图一样。也正因此，我们通常指后提交的快照为“上游”，之前提交的为“下游”。 眼尖的小伙伴应该已经注意到了，图中除了哈希值代表的工作目录快照外，还有master和HEAD两个莫名奇妙的东西。不瞒你说，这俩家伙都是Git内的指针，其中master是Git仓库在初始化时产生的默认分支，其名称并没有特别之处。我们可以说，在Git里，分支就是指针，一个普通的指针就对应一个分支。需要注意的是，另一个全部大写的HEAD是一个非常特殊的指针，它指向当前的分支，换句话说，它决定了你当前的修改会提交在哪个分支。 我们可以打一个非常有意思的比方，我们把文件的提交，或者说仓库的向上游的扩展看作是修路，那么master就代表一个没有包工头的施工队，而HEAD就是包工头（当然是你自己啦）。我们的包工头带领哪个施工队，工程就会在那个施工队的后面延续。而当有多个施工队时，其他的施工队就处于窝工状态。所以我们可以考察下面这种情况，我们在g38jg处新建一个分支，即生成名为joker的指针，再令HEAD指向它，那我们在修改文件提交后，仓库是在A处延续还是在B处呢？ 答案是在A处延续，毕竟包工头HEAD安排的是joker搬砖嘛。 OK，有了这些感性认识之后，后面的学习相信会容易很多。 常用命令本来想着按照教程的思路去解释各种命令，但是廖雪峰的官方网站已经展示了新手向的引导，且Git帮助文档也给出了非常详细的教程。以我的水平，也没必要再在这里赘述，倒不如给出常用的命令列表，再用一个实例进行说明。 下列命令中的&lt;example&gt;均为示例，实际使用时连同尖括号一起替换为相应参数。 非常抱歉地告诉朋友们，下图中“第一次使用前必要的配置”两条命令都被我写错了，但我还是懒得修改图片，直接在这里更正好了： 123&gt; git config --global user.name &lt;username&gt;&gt; git config --global user.email &lt;email@email.com&gt;&gt; 12345678910111213![](cmd.jpg)Git的分支是杀手锏武器，开发者也非常鼓励大家在使用的时候频繁利用分支进行管理。例如需要进行版本回退时，可以创建个指向回退版本的分支，在那个分支上进行修改，验证可行后将其合并到主分支即可。这就避免了“吃了后悔药之后又后悔”的情况。# 一个栗子最近老板让我整理一个系统仿真模型，这个模型不同于我之前搭建的模型，所以我选择新建一个文件夹来专门处理这个事情，同时，我希望用Git对该任务进行管理。我决定采用这种方式进行：以Git的__master__分支作为主分支，始终保持其正确性，其他所有的任务都在临时的分支中进行，调试完成后再合并到主分支。## 工作目录初始化假设这个项目的代号为A，于是我新建了一个名为__ProjectA__的文件夹，并右键打开Git Bash Here，运行​```gitgit init 虽然Git Bash提示我成功创建了一个仓库，但文件夹内没有看到任何新文件。不要紧，因为之前说过Git仓库不显示在工作目录，实际上它是一个隐藏文件，一般人千万不要去修改它。 接着我打开MATLAB，想到后面的工作会在Simulink上进行，而Simulink在运行时会产生一个名为slprj的文件夹，用来保存仿真过程中的各种信息。我不希望这个文件夹进入Git仓库，所以需要让Git忽略它。为此，我们需要编写一个名为.gitignore的文本文件。 如果你尝试新建txt文件，然后强行改名，Windows会提示你必须键入文件名（它一般不允许以小数点开头的文件）。这时，我们可以先打开notepad++，编辑好内容后保存，这时从提示框内输入以点开头的文件名是可行的，注意不要选任何后缀。对我而言，既然已经打开MATLAB了，直接用MATLAB编辑不就好了嘛。于是我在MATLAB中输入edit .gitignore，在弹出的文件编辑器内输入‘slprj/’后保存。于是Git以后就会忽略这个文件夹了。 又想到，Git可以对文本文件进行对比，并在有差异的地方插入提示符以凸显。然而Simulink模型是二进制文件，如果Git把它当成文本文件对比并修改，我的模型可能就前功尽弃了。因此我要告诉Git哪些文件是二进制文件，在对比差异的时候不要进行修改。所以我又新建了一个名为.gitattributes的文件，在其中添加了以下内容： 123456789101112131415161718192021222324*.mlx -crlf -diff -merge*.mat -crlf -diff -merge*.fig -crlf -diff -merge*.mdl -crlf -diff -merge*.slx -crlf -diff -merge*.mlapp -crlf -diff -merge*.p -crlf -diff -merge*.mdlp -crlf -diff -merge*.slxp -crlf -diff -merge*.sldd -crlf -diff -merge*.slxc -crlf -diff -merge*.mlproj -crlf -diff -merge*.mldatx -crlf -diff -merge*.slreqx -crlf -diff -merge*.sfx -crlf -diff -merge*.sltx -crlf -diff -merge*.mexa64 -crlf -diff -merge*.mexw64 -crlf -diff -merge*.mexmaci64 -crlf -diff -merge*.xlsx -crlf -diff -merge*.docx -crlf -diff -merge*.pdf -crlf -diff -merge*.jpg -crlf -diff -merge*.png -crlf -diff -merge 为了纪念这个开头，我希望将这两个以小数点开头的文件保存到Git仓库，于是我在Git Bash中分别运行了下面两个命令 12git add .git commit -m &apos;Init Git: add configuration&apos; 至此，该项目的初始化配置就完成了。我又用git status命令确认了下当前状态，Bash提示我当前在master分支，工作树很干净，这说明我的操作是正确的。 添加文件并提交修改前期的工作都是最基本的参数录入、函数编写等不容易犯错的事情，并且刚开始还没有形成稳定的版本，所以我决定前期直接在master分支进行工作。第一天，我完成了参数的导入和函数的编写，在下班前，我把这些工作保存到Git仓库。 12git add .git commit -m &apos;load para and design fcn&apos; 同样地，第二天我实现了仿真模型的建立，第三天我获得了初步的控制参数，这些都分别利用add和commit提交到了Git仓库。下班之前，我想看看之前的进展，于是在Git Bash中输入git log --oneline，我看到以下内容 123456chunyu@MyPC /d/iGitHubs/ProjectA (master)$ git log --onelineb483575 (HEAD -&gt; master) get primary ctrl-para3ddb6c9 finish simulink model5752ad5 load para and design fcnd942761 Init Git: add configuration 可见，目前HEAD指针在master分支处，且处于b483575这个快照处，备注说获得了初步的控制参数。至此，我的模型已经基本可用，或者说项目达到了一个初始阶段，后面的工作都可以以此为基准进行，换句话说，后面的工作可以以该处为节点进行分支。 撤销操作第四天起来头脑有点不清醒，我直接在仿真模型中进行修改并尝试更好的参数。没多久，我想起来如果我把参数改乱了，仿真模型就不能用了，这些操作我应该在一个新的分支中进行，所以我需要撤销这些操作，而我又忘记撤销的命令了，于是我在Git Bash中利用git status查看了当前状态，我得到 123456789chunyu@MyPC /d/iGitHubs/ProjectA (master)$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: SimModel.slxno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 它提示我要么用add将修改添加到暂存区，或者用restore放弃修改。于是我用git restore .丢弃了这次的所有操作。 分支管理喝了杯咖啡，头脑清醒些了，于是我用以下命令新建并转到一个名为TunePara的新分支上 1git switch -c TunePara 在新的分支下，我就可以不用担心模型被弄乱，从而为所欲为了。 在接下来几个小时内，我调了很多组不同的参数，虽然可用，但还是没有达到我的预期效果。但我还是将这些过程添加到了Git仓库，现在，我的Git历史看起来是这个样子 12345678910chunyu@MyPC /d/iGitHubs/ProjectA (TunePara)$ git log --oneline294c42d (HEAD -&gt; TunePara) 60Hz Parad003db0 50Hz Paraadaef2f 40Hz Para7e9d9a4 30Hz Parab483575 (master) get primary ctrl-para3ddb6c9 finish simulink model5752ad5 load para and design fcnd942761 Init Git: add configuration 可以看出，我的master分支停留在的b483575这个稳定版本，而TunePara分支已经发展了四次。 这时，老板让我随便用一套参数做一个他临时想到的方案测试。由于参数还没有调到理想状态，我觉得用初始参数去尝试就好。因此，我提交当前工作后，用以下两个命令在b483575处又新建了一个名为SimModel的分支，并切换过去。 12git branch SimModel b483575git switch SimModel 我去？刚刚调参数写的一些新函数全部不见了？不用担心，因为那些函数在TunePara分支上，而现在在SimModel分支，看到的东西当然不太一样了。但是，既然这是另一个分支，我当然也是可以为所欲为的了。 我在SimModel分支提交了一些工作，由于已经有了三个分支，为了清楚地看现在Git的全部历史，我采用了git log --oneline --graph --all命令，然后看到 123456789101112131415chunyu@MyPC /d/iGitHubs/ProjectA (SimModel)$ git log --oneline --graph --all* 64ec543 (HEAD -&gt; SimModel) Exp3* a075106 Exp2* 4b6dbcf Exp1| * 3ce0291 (TunePara) TempBreak to SimModel| * 294c42d 60Hz Para| * d003db0 50Hz Para| * adaef2f 40Hz Para| * 7e9d9a4 30Hz Para|/* b483575 (master) get primary ctrl-para* 3ddb6c9 finish simulink model* 5752ad5 load para and design fcn* d942761 Init Git: add configuration 按照时间顺序的话，我们应当从下往上看。其中，短线表示的是分支，星号表示Git储存的快照，其哈希值在同一行，其后就是当次提交的备注。应当注意的是，如果将该仓库克隆到其他电脑，哈希值可能会变。因此，写好备注是非常重要的。 老板觉得仿真基本达到预期效果，但还是要求参数调好之后重新仿真，因此我又要暂停这个任务，使用git switch TunePara跳转到TunePara分支上继续进行参数设计。 多次尝试后，最终获得了理想的控制参数，那么主分支master就应该向上游推进。也就是说，我们需要将最终完成后的TunePara分支合并到master分支。我们只需要切换到master分支再利用merge命令即可： 12git switch mastergit merge TunePara 然后我们会看到更新完成并有‘Fast-forward’的提醒。再看Git历史 1234567891011121314151617chunyu@MyPC /d/iGitHubs/ProjectA (master)$ git log --oneline --graph --all* 5dec3a7 (HEAD -&gt; master, TunePara) Final Para* 3ce0291 TempBreak to SimModel* 294c42d 60Hz Para* d003db0 50Hz Para* adaef2f 40Hz Para* 7e9d9a4 30Hz Para| * e8faa02 (SimModel) Exp4| * 64ec543 Exp3| * a075106 Exp2| * 4b6dbcf Exp1|/* b483575 get primary ctrl-para* 3ddb6c9 finish simulink model* 5752ad5 load para and design fcn* d942761 Init Git: add configuration 可以看到由于TunePara分支是由之前master分支所在的b483575快照处直接延伸过去的，也就是说从b483575快照到最终的TunePara分支处是一条直线，所以合并时不存在文件冲突，直接快进到上游区，最终使master和TunePara指向同一快照。 至此，我不再需要TunePara分支了，故将其删除。 1git branch -d TunePara 现在，完美的模型在master分支，而仿真需要的其他文件在SimModel分支，为了形成一个新的稳定版本，这两个分支需要合并，我尝试在master分支直接合并SimModel分支的内容： 123456chunyu@MyPC /d/iGitHubs/ProjectA (master)$ git merge SimModelwarning: Cannot merge binary files: Moldel.slx (HEAD vs. SimModel)Auto-merging Moldel.slxCONFLICT (content): Merge conflict in Moldel.slxAutomatic merge failed; fix conflicts and then commit the result. 它说，无法自动合并二进制文件，需要我们手动处理。此时我们如果关注命令行的括号，它已经从(master)变成了(master|MERGING)，说明我们确实需要手动进行合并。这是因为我们在初始化使设置了仿真模型文件作为二进制文件，Git将不会主动修改它。 显然，SimModel分支里的模型是旧的，我们应当保留master分支中的文件，因此我们需要运行 1git checkout Model.slx --ours 最后的--ours代表当前分支的文件，若想采用另一分支的文件，可改用--theirs参数。合并之后不妨用git status查看下状况，Git就会提示这次合并需要输入备注才能提交到Git仓库，因此我们提交本次合并的注释 1git commit -m &apos;merge sim model&apos; 最后看一眼整个历史 12345678910111213141516171819chunyu@MyPC /d/iGitHubs/ProjectA (master)$ git log --oneline --graph --all* 5512a06 (HEAD -&gt; master) merge sim model|\| * e8faa02 (SimModel) Exp4| * 64ec543 Exp3| * a075106 Exp2| * 4b6dbcf Exp1* | 5dec3a7 Final Para* | 3ce0291 TempBreak to SimModel* | 294c42d 60Hz Para* | d003db0 50Hz Para* | adaef2f 40Hz Para* | 7e9d9a4 30Hz Para|/* b483575 get primary ctrl-para* 3ddb6c9 finish simulink model* 5752ad5 load para and design fcn* d942761 Init Git: add configuration 可见，合并后master分支又向上游推进了一步，而SimModel分支保持不变。至此，第一阶段的工作已经完成，用git branch -d SimModel删除多余的分支，等待下一次任务吧。 写在后面在这篇博客写完的时候，本人对Git的使用也不到一个月的时间，故其中难免有不周全的地方。对Git有兴趣的同学可以阅读Git官方提供的参考书Pro Git或直接阅读Git帮助文档。祝大家学习愉快！]]></content>
      <categories>
        <category>相见恨晚</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LPSD功率谱估计]]></title>
    <url>%2F2019%2F09%2F18%2FLPSD%2F</url>
    <content type="text"><![CDATA[欧洲航空局（ESA）为LISA计划设计了完整的数据处理工具包LTPDA （LISA Technology Package Data Analysis），该工具包中内置一种对数频率点功率谱估计算法，即本文所提的LPSD算法。该算法由文献Improved spectrum estimation from digitized time series on a logarithmic frequency axis 给出。本文作为对该文献学习的总结，同时作为对MATLAB的学习，自编了基于LPSD算法的功率谱估计函数。 常用功率谱估计算法功率谱估计是频域分析的一种常用手段，可用来检测信号中的单频信号或评估仪器的噪声本底等。常用的功率谱估计算法有周期图法（对应MATLAB函数为periofogram）和Welch方法（pwelch）。对于采集系统收集到的数字信号，周期图法会对该数据进行去漂（detrend）和加窗，然后利用快速傅里叶变换（FFT，是DFT的快速算法）将信号转化到频域$$X(k) = \sum\limits_{n = 0}^{N - 1} {x(n){e^{ - i\frac{ {2\pi} } {N}nk}}}$$ 最后利用Parseval等式获得功率谱$$S(k) = \frac{2}{Nf_s}|X(k)|^2$$ 式中，系数2是将双边谱转换到单边谱，这是因为负频率不具备实际的物理意义。Welch方法相对于周期图法增加了分段平均的思想，其将数据等分为多段，并且允许各段数据之间具有一定的重叠率以补偿窗函数引入的数据不平权的影响。对每段数据采用周期图法，最后将各段分别计算的功率谱进算数平均，获得最终的谱估计值。图中展示了周期图法和Welch方法对功率谱估计的结果。其中，蓝色曲线的周期图法一次性使用了全部的数据，因而有最高的频率分辨率，可以看到更低的频带。但是其高频部分的数据波动较大，且波动范围不会随着点数的增加而减小，即不满足所谓的一致性原则。橙色的Welch算法由于对数据进行了分段，直接进行FFT的数据相对较少，导致频率分辨率降低。但是分段平均使得高频波动的幅值大大减小，可以证明波动会随着分段次数的增加而进一步减小。 LPSD算法LPSD算法的基本思想是采用对数分布的频率点，由于此时频率点的差值不是定值，即DFT的频率分辨率随频率点变化，因而在求取每个频率点对应的功率谱密度时应当对原始数据进行不同的分段。这就是说，LPSD算法的每个频率点对应于不同分段次数下Welch算法中的相应点。 对数频率的选取记采集到的离散数据为$x(n),n=0,1,2…N-1$，采样率为$f_s$。假设希望计算$J_{des}$个点，其中第$j$个点对应的频率为$f(j)$、功率谱密度为$P(j)$、频率分辨率为$r(j)=f(j+1)-f(j)$。应当注意的是，这里的频率分辨率是指计算DFT的频率点之间的间隔，更一般的说法应当是栅栏效应。有限长数据的频率分辨率实际由DTFT定义，与数据的时间长度互为导数，本文中称之为最小分辨率。在LPSD算法中不能采用logspace生成对数分布的频率点，因为数值计算的频率间隔不应当小于最小分辨率$r_{min}$，否则这种计算是没有意义的。为了计算频率点，首先考察严格对数均匀的频率点应当满足$$\log f(j + 1) - \log f(j) = C$$其中C为常数。频率范围受分辨率和采样率的影响，取$$f(1)=r_{min}=\frac{f_s}{N},f(J_{des})=f_{max}=\frac{f_s}{2}$$再令$$g=\log f_{max}- \log r_{min}=\log \frac{N}{2}$$ 可以得到第$j$个点的频率和频率分辨率分别为$$f(j)=r_{min} \times 10^{\frac{j-1}{J_{des}-1}g} \\ r_0(j)=f(j)(10^{\frac{g}{J_{des}-1}}-1)$$ 为了使低频段到高频段的频率分辨率变化较连续，对中频段对应的频率分辨率进行调整，为此，引入分段次数期望值$K_{des}$（其典型值为100），在分段重叠率为$\xi$时满足$$({K_{des}} - 1)(1 - \xi ){L_{avg}} + {L_{avg}} = N$$ 此时对应的频率分辨率为$$r_{avg}=\frac{f_s}{L_{avg}}=\frac{f_s}{N}[ (K_{des}-1)(1-\xi) +1 ]$$ 根据分辨率限制和算法需求，我们需要对频率分辨率进行调整，如下$$r’(j) = {\begin{array}{|cc}r_0(j) &amp; ,r_0(j)\ge r_{avg} \\\sqrt{r_0(j) \cdot r_{avg}} &amp; ,r_0(j) &lt; r_{avg}{\rm{ and }}\sqrt{r_0(j) \cdot r_{avg}} &gt; r_{\min } \\r_{min} &amp; ,else \\\end{array}}$$ 除此之外，为了保证依据频率分辨率分段的数据长度为整数，频率分辨率还应当做进一步调整$$L(j) = \left\lfloor{\frac{f_s}{r’(j)}} \right\rfloor \\ r(j) = \frac{f_s}{L(j)}$$ 其中，符号$\left\lfloor \right\rfloor$表示向下取整。综上所述，对数频率的选取算法为：以$f(1)=r_{min}$为起点，根据频率和$J_{des}$求解分辨率$r_0(j)$，并根据要求对分辨率进行调整，得到$r(j)$，接着利用$f(j+1)=f(j)+r(j)$进行迭代。当计算的频率达到奈奎斯特频率即可停止迭代。值得注意的是，由于对频率分辨率进行了修正，获得的频率点并不是严格的对数分布，同时也会导致实际获得的频率点$J$与期望的点数$J_{des}$并不相等。 数据的分段处理对于第$j$个频率点，由前可知其频率分辨率为$r(j)$，分段后的每段数据长度为$L(j)$。为了减小窗函数导致的数据不等权，允许分段之间存在一定的重叠率$\xi$，数据分段如下图所示。由图可知，每段数据未重叠部分长度为$$D(j) = (1 - \xi ) \cdot L(j)$$ 因而分段次数为$$K(j) = \left\lfloor {\frac{N - L(j)} {D(j) + 1} } \right\rfloor $$ 针对每段数据，我们可以选择利用mean函数求取数据平均值后予以扣除，或利用detrend函数直接去除数据中线性漂移。以扣除平均值为例，第$j$个频率点的第$k$段数据平均值为$$a(j,k) = \frac{1}{L(j)}\sum\limits_{l = 1}^{L(j)} {x\left( {D(j) \cdot (k - 1) + l} \right)}$$ 将该段数据扣除平均值后，以相同长度的窗函数$w(j,l)$对数据段进行加窗，得到预处理的数据段$$\begin{array}{r}G(j,k,l) = \left[ {x\left( {D(j) \cdot (k - 1) + l} \right) - a(j,k)} \right] \cdot w(j,l)\l = 1,2,3…L(j)\end{array}$$ 然后对$G(j,k,l)$进行离散傅里叶变换$$A(j,k) = \sum\limits_{l = 1}^{L(j)} {G(j,k,l) \cdot {e^{ - 2\pi i\frac{m(j)}{L(j)}l} } } $$ 应当注意的是$G(j,k,l)$中$j$表示频率点、$k$表示分段、$l$代表数据在分段内的位置，因此$l$对应傅里叶变换的时间变量。严格来说，上式是离散傅里叶变换第$m(j)$个点的值。其中$$m(j)=\frac{f(j)}{r(j)}$$ 在FFT算法中，$m(j)$应当是整数，而此处不一定满足该要求，故LPSD算法不能利用FFT进行加速，这是该算法耗时较长的原因之一。对$m(j)$的具体讨论详见文献，此处不作赘述。在进行以上操作后，我们得到了第$j$个频率点对应的$K(j)$段数据DFT的$K(j)$个单点值，对这些值进行算数平均，根据Parseval等式可得谱密度为$$P(j) = \frac{C}{K(j)}\sum\limits_{k = 1}^{K(j)} { { {\left| {A(j,k)} \right|}^2} } $$ 其中$C$为归一化系数，由下一节进行讨论。 功率谱的归一化功率谱的归一化系数与窗函数相关，而窗函数可根据不同需求进行不同的选择。对于任意窗函数$w(j,l)$，做如下定义$${S_1}(j) = \sum\limits_{l = 1}^{L(j)} {w(j,l)} \\{S_2}(j) = \sum\limits_{l = 1}^{L(j)} { {w^2}(j,l)} $$ 单边谱的归一化系数可按下式进行计算$${C_{PS} }(j) = \frac{2}{ {S_1^2(j)} }\\{C_{PSD} }(j) = \frac{2}{ { {f_s} \cdot {S_2}(j)} }$$ 其中，$C_{PS}$是功率谱的归一化系数，常用于单频信号的处理。由于绝大多数信号都均匀丰富的频率成分，我们更多地采用功率谱密度，其对于的归一化系数为$C_{PSD}$。以电压为例，功率谱的单位是${\rm V}^2$，而功率谱密度的单位是${\rm V}^2/{\rm Hz}$。在习惯上，我们所说的功率谱值得都是功率谱密度，且取其开方值，单位为${\rm V}^2/\sqrt{ {\rm Hz} }$。至此，我们依据实现的功率谱的求取，以$f(j)$为横轴，$P(j)$为纵轴即可绘制功率谱。 不同算法的对比依然以本文开头的数据为例，周期图法、Welch方法以及LPSD算法得到的功率谱如下图所示。 可见，LPSD算法在低频出有更高的频率分辨率，在高频对谱密度的估计更准确，兼顾了周期图法和Welch方法的优点。然而LPSD算法牺牲了数值计算的速度，在一次利用400万个数据做谱的测试中，各算法的耗时如下。其中iParLPSD是利用了MATLAB并行工具包计算的LPSD算法。 MATLAB源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138% Use LPSD mothod to plot power spectral density% [Pxx,f] = iLPSD(Data,fs,Jdes)% Data --- Input data, it must be column vector% fs --- Sample frequency, unit: Hz% Jdes --- Desired frequency points, default: 1000% Pxx --- One-sided PSD, unit: *^2/Hz% f --- Frequency points related to PSD points, unit: Hz% Default window function is hanning window.% Demo:% iLPSD(data,fs)% Plot PSD using default settings.% h = iLPSD(data,fs,Jdes)% Plot PSD with desired points Jdes% [Pxx,f] = iLPSD(data,fs)% Return PSD points, don't plot any figure% Reference DOI: 10.1016/j.measurement.2005.10.010% XiaoCY 2019-04-10%% Mainfunction varargout = iLPSD(varargin) nargoutchk(0,2); narginchk(2,3); data = varargin&#123;1&#125;; fs = varargin&#123;2&#125;; if nargin == 3 Jdes = varargin&#123;3&#125;; else Jdes = 1000; end Kdes = 100; ksai = 0.5; N = length(data); [f,L,m] = getFreqs(N,fs,Jdes,Kdes,ksai); J = length(f); P = zeros(J,1); for j = 1:J % Use 'parfor' here to enable parallel computation Dj = floor((1-ksai)*L(j)); Kj = floor((N-L(j))/Dj+1); w = hann(L(j)); C_PSD = 2/fs/sum(w.^2); l = (0:L(j)-1)'; W1 = cos(-2*pi*m(j)/L(j).*l); W2 = sin(-2*pi*m(j)/L(j).*l); A = 0; for k = 0:Kj-1 G = data(k*Dj+1:k*Dj+L(j)); G = G-mean(G);% G = detrend(G); G = G.*w; A = A + (G.'*W1)^2+(G.'*W2)^2; end P(j) = A/Kj*C_PSD; end switch nargout case 0 h = PlotPSD(P,f); case 1 h = PlotPSD(P,f); varargout&#123;1&#125; = h; case 2 varargout&#123;1&#125; = P; varargout&#123;2&#125; = f; otherwise % Do Nothing endend%% Subfunctions% get logarithmic frequency pointsfunction [f,L,m] = getFreqs(N,fs,Jdes,Kdes,ksai) fmin = fs/N; fmax = fs/2; r_avg = fs/N*(1+(1-ksai)*(Kdes-1)); g = (N/2)^(1/(Jdes-1))-1; f = zeros(Jdes,1)-1; L = f; m = f; j = 1; fj = fmin; while fj &lt; fmax rj = fj*g; if rj &lt; r_avg rj = sqrt(rj*r_avg); end if rj &lt; fmin rj = fmin; end Lj = floor(fs/rj); rj = fs/Lj; mj = fj/rj; f(j) = fj; L(j) = Lj; m(j) = mj; fj = fj+rj; j = j+1; end f(f&lt;0) = []; L(L&lt;0) = []; m(m&lt;0) = [];end% plot PSDfunction hLine = PlotPSD(P,f) hLine = loglog(f,sqrt(P)); hFig = gcf; hFig.Color = 'w'; hAxes = gca; hAxes.FontSize = 18; hAxes.FontWeight = 'bold'; hAxes.XGrid = 'on'; hAxes.YGrid = 'on'; hAxes.XLabel.String = 'Frequency (Hz)'; hAxes.YLabel.String = 'PSD ([Unit]/Hz^&#123;1/2&#125;)'; hAxes.XLabel.FontSize = 20; hAxes.YLabel.FontSize = 20; hAxes.XLabel.FontWeight = 'bold'; hAxes.YLabel.FontWeight = 'bold'; hLine.LineWidth = 2; end]]></content>
      <categories>
        <category>数据处理</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>功率谱</tag>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中秋节快乐]]></title>
    <url>%2F2019%2F09%2F13%2FMidAutumn%2F</url>
    <content type="text"><![CDATA[但愿人长久，千里共婵娟。苏轼（水调歌头） 第一次写博客，也不知道该写一些什么，既然今天是中秋节，那就祝大家中秋节快乐吧！ 今天也正好是我两个好朋友的生日，他们是Randy和玉玺。本想着写点什么文艺的话，可是呢，你们懂的。不管怎样，蛋糕还是要吃的，祝你们生日快乐，万事如意！ 今天给翠翠秀我的博客时，他要求我把他也写上，这可真是为难我了，想想，不如就写写“翠翠”这个名字的来源吧。在翠翠成为翠翠之前，我们都以“二哥”来称呼他。那是高中第一次做化学实验的时候，老师一再强调小心轻放不要把玻璃仪器摔坏了，即使如此，也不能阻挡动手能力强的翠翠在一节课的时间内摔坏一个试管和一个容量瓶。课后我们用方言调侃他，叫他“cei cei”。不久，在我们学了《边城》之后，“cei cei”就变成了翠翠。 写的有点乱，既然这样，那再秀一下我女朋友今天做的菜吧，真香。]]></content>
      <categories>
        <category>生活记事</category>
      </categories>
      <tags>
        <tag>闲谈</tag>
      </tags>
  </entry>
</search>
